{"version":3,"sources":["webpack:///./node_modules/events/events.js","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/camera.js","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/captor.js","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/captors/mouse.js","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/captors/utils.js","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/easings.js","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/endpoint.js","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/heuristics/labels.js","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/heuristics/z-index.js","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/node_modules/@yomguithereal/helpers/extend.js","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/node_modules/graphology-metrics/extent.js","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/node_modules/graphology-utils/is-graph.js","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/quadtree.js","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/renderer.js","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/renderers/canvas/components/edge-label.js","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/renderers/canvas/components/hover.js","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/renderers/canvas/components/label.js","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/renderers/canvas/components/node.js","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/renderers/display-data.js","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/renderers/utils.js","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/renderers/webgl/index.js","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/renderers/webgl/matrices.js","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/renderers/webgl/programs/arrow.js","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/renderers/webgl/programs/edge.arrow.js","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/renderers/webgl/programs/edge.clamped.js","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/renderers/webgl/programs/edge.js","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/renderers/webgl/programs/node.fast.js","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/renderers/webgl/programs/program.js","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/renderers/webgl/settings.js","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/renderers/webgl/shaders/arrow.frag.glsl","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/renderers/webgl/shaders/arrow.vert.glsl","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/renderers/webgl/shaders/edge.clamped.vert.glsl","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/renderers/webgl/shaders/edge.frag.glsl","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/renderers/webgl/shaders/edge.vert.glsl","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/renderers/webgl/shaders/node.fast.frag.glsl","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/renderers/webgl/shaders/node.fast.vert.glsl","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/renderers/webgl/shaders/utils.js","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/renderers/webgl/utils.js","webpack:///C:/Users/pudding/AppData/Roaming/npm/node_modules/sigma/utils.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,sBAAsB;AACvC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,QAAQ,yBAAyB;AACjC;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;;;;;;;;;;;;AC/ba;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,cAAc,mBAAO,CAAC,+CAAQ;;AAE9B,sCAAsC,mBAAO,CAAC,6FAAW;;AAEzD,aAAa,mBAAO,CAAC,yFAAS;;AAE9B,qCAAqC,gDAAgD,2BAA2B,iEAAiE,cAAc,GAAG,cAAc;;AAEhN,uCAAuC,6BAA6B,YAAY,EAAE,8EAA8E,SAAS,kBAAkB,EAAE,wCAAwC,+BAA+B,uBAAuB,EAAE,iBAAiB,sFAAsF,uBAAuB,sDAAsD,qFAAqF,sCAAsC,0CAA0C,EAAE,OAAO,wBAAwB,EAAE,EAAE,EAAE,yBAAyB,aAAa,wBAAwB,EAAE,eAAe;;AAE5uB,uBAAuB,2EAA2E,kCAAkC,mBAAmB,GAAG,EAAE,OAAO,kCAAkC,8HAA8H,GAAG,EAAE,qBAAqB;;AAE7V,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE;;AAE3T,6DAA6D,sEAAsE,8DAA8D,oBAAoB;;AAErN,iDAAiD,0EAA0E,aAAa,EAAE,qCAAqC;;AAE/K,uCAAuC,uBAAuB,uFAAuF,EAAE,aAAa;;AAEpK,6BAA6B,gGAAgG,gDAAgD,GAAG,2BAA2B;;AAE3M,0CAA0C,+DAA+D,2EAA2E,EAAE,yEAAyE,eAAe,sDAAsD,EAAE,EAAE,uDAAuD;;AAE/X,gCAAgC,4EAA4E,iBAAiB,UAAU,GAAG,8BAA8B;;AAExK;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,iFAAiF;;AAEjF;AACA;AACA;AACA,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA,qDAAqD;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA,qCAAqC;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB,SAAS;AACzB,gBAAgB,SAAS;AACzB;;AAEA,GAAG;AACH;AACA;AACA;;AAEA,qCAAqC;;AAErC,qCAAqC;AACrC,mGAAmG;;AAEnG,+DAA+D;;AAE/D;AACA,yCAAyC;;AAEzC;AACA,wDAAwD;;AAExD;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,SAAS,EAAE;AACX;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,SAAS,EAAE;AACX;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA,CAAC;;AAED,4B;;;;;;;;;;;;AC3Wa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,cAAc,mBAAO,CAAC,+CAAQ;;AAE9B,uBAAuB,2EAA2E,kCAAkC,mBAAmB,GAAG,EAAE,OAAO,kCAAkC,8HAA8H,GAAG,EAAE,qBAAqB;;AAE7V,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,iDAAiD,0EAA0E,aAAa,EAAE,qCAAqC;;AAE/K,uCAAuC,uBAAuB,uFAAuF,EAAE,aAAa;;AAEpK,6BAA6B,gGAAgG,gDAAgD,GAAG,2BAA2B;;AAE3M,0CAA0C,+DAA+D,2EAA2E,EAAE,yEAAyE,eAAe,sDAAsD,EAAE,EAAE,uDAAuD;;AAE/X,gCAAgC,4EAA4E,iBAAiB,UAAU,GAAG,8BAA8B;;AAExK;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,iFAAiF;;AAEjF;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED,4B;;;;;;;;;;;;AC3CA,oDAAa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,qCAAqC,mBAAO,CAAC,4FAAW;;AAExD,qCAAqC,mBAAO,CAAC,4FAAW;;AAExD,aAAa,mBAAO,CAAC,kGAAS;;AAE9B,sCAAsC,uCAAuC,kBAAkB;;AAE/F,uBAAuB,2EAA2E,kCAAkC,mBAAmB,GAAG,EAAE,OAAO,kCAAkC,8HAA8H,GAAG,EAAE,qBAAqB;;AAE7V,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE;;AAE3T,6DAA6D,sEAAsE,8DAA8D,oBAAoB;;AAErN,iDAAiD,0EAA0E,aAAa,EAAE,qCAAqC;;AAE/K,6BAA6B,gGAAgG,gDAAgD,GAAG,2BAA2B;;AAE3M,uCAAuC,uBAAuB,uFAAuF,EAAE,aAAa;;AAEpK,0CAA0C,+DAA+D,2EAA2E,EAAE,yEAAyE,eAAe,sDAAsD,EAAE,EAAE,uDAAuD;;AAE/X,gCAAgC,4EAA4E,iBAAiB,UAAU,GAAG,8BAA8B;;AAExK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,yGAAyG;;AAEzG;AACA,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA,0EAA0E;;AAE1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO,wBAAwB;;AAE/B;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,oEAAoE;;AAEpE;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,+CAA+C;AAC/C;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA,+CAA+C;AAC/C;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA,iCAAiC;AACjC;AACA,GAAG;;AAEH;AACA,CAAC;;AAED,iC;;;;;;;;;;;;;ACnUa;;AAEb;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,+GAAoB;;AAEzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA,YAAY;AACZ;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB;;;AAGA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC9Ha;;AAEb;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,gC;;;;;;;;;;;;ACvDa;;AAEb;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,uCAAuC,mBAAO,CAAC,+FAAY;;AAE3D,qCAAqC,mBAAO,CAAC,2FAAU;;AAEvD,uCAAuC,mBAAO,CAAC,+FAAY;;AAE3D,oCAAoC,mBAAO,CAAC,0GAAiB;;AAE7D,oCAAoC,mBAAO,CAAC,qHAAmB;;AAE/D,sCAAsC,uCAAuC,kBAAkB,E;;;;;;;;;;;;AC9ClF;;AAEb;AACA;AACA,CAAC;AACD;AACA;;AAEA,qCAAqC,mBAAO,CAAC,4FAAW;;AAExD,sCAAsC,uCAAuC,kBAAkB;;AAE/F;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,IAAI;AAChB,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;;AAEA,mDAAmD;;AAEnD,oJAAoJ;;AAEpJ;AACA;AACA;AACA;AACA,gFAAgF;;AAEhF,qGAAqG;;AAErG,mGAAmG;;AAEnG,4EAA4E;;AAE5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;;AAEnC;AACA;AACA;AACA;;AAEA,0CAA0C,OAAO;AACjD;AACA,+BAA+B;;AAE/B,oEAAoE;;AAEpE,yEAAyE;AACzE;;AAEA,4GAA4G;;AAE5G;AACA;AACA;AACA,KAAK;AACL;;;AAGA;AACA,oFAAoF;;AAEpF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,+CAA+C;;AAE/C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;;AAGA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,GAAG;;;AAGH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;;AAGH,uEAAuE;;AAEvE;;AAEA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;;AAEA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA,GAAG;;;AAGH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,IAAI;AAChB,YAAY,IAAI;AAChB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;;AAEjE;AACA;;AAEA,iBAAiB,kCAAkC;AACnD;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;AACA,GAAG;;;AAGH,mBAAmB,uCAAuC;AAC1D;;AAEA;;AAEA,oBAAoB,oBAAoB;AACxC;AACA;AACA;;AAEA;AACA,C;;;;;;;;;;;;ACrRa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,EAAE;AACL,C;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,iBAAiB,QAAQ;AACzB;AACA;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mBAAO,CAAC,8IAA2B;;AAEjD;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,aAAa;AACzB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,aAAa,uBAAuB;AACpC;;AAEA;AACA;;AAEA,+BAA+B,OAAO;AACtC;AACA;;AAEA,eAAe,uBAAuB;AACtC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,aAAa;AACzB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,aAAa,uBAAuB;AACpC;;AAEA;AACA;;AAEA,+BAA+B,OAAO;AACtC;AACA;;AAEA,eAAe,uBAAuB;AACtC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,IAAI;AAChB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtBa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,qCAAqC,mBAAO,CAAC,uJAA+B;;AAE5E,sCAAsC,uCAAuC,kBAAkB;;AAE/F,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE;;AAE3T,6DAA6D,sEAAsE,8DAA8D,oBAAoB;;AAErN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uHAAuH;;AAEvH,wMAAwM;;AAExM,mNAAmN;AACnN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B;;AAE5B;AACA,sEAAsE;;AAEtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;;;AAGA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED,8B;;;;;;;;;;;;ACxUa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,cAAc,mBAAO,CAAC,+CAAQ;;AAE9B,uBAAuB,2EAA2E,kCAAkC,mBAAmB,GAAG,EAAE,OAAO,kCAAkC,8HAA8H,GAAG,EAAE,qBAAqB;;AAE7V,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,iDAAiD,0EAA0E,aAAa,EAAE,qCAAqC;;AAE/K,uCAAuC,uBAAuB,uFAAuF,EAAE,aAAa;;AAEpK,6BAA6B,gGAAgG,gDAAgD,GAAG,2BAA2B;;AAE3M,0CAA0C,+DAA+D,2EAA2E,EAAE,yEAAyE,eAAe,sDAAsD,EAAE,EAAE,uDAAuD;;AAE/X,gCAAgC,4EAA4E,iBAAiB,UAAU,GAAG,8BAA8B;;AAExK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;;AAED,8B;;;;;;;;;;;;AC1Ca;;AAEb;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C;AAC1C,GAAG;AACH,oDAAoD;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACvCa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,mCAAmC,mBAAO,CAAC,sHAAQ;;AAEnD,oCAAoC,mBAAO,CAAC,wHAAS;;AAErD,sCAAsC,uCAAuC,kBAAkB;;AAE/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;;AAEzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB,uCAAuC;;AAEvC;AACA,C;;;;;;;;;;;;ACvDa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACpBa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACrBa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE;;AAE3T,6DAA6D,sEAAsE,8DAA8D,oBAAoB;;AAErN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED,0C;;;;;;;;;;;;AC/Ea;;AAEb;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA,iCAAiC,oFAAoF;;AAErH,6BAA6B,6EAA6E;;AAE1G,wCAAwC,yGAAyG,QAAQ,EAAE,eAAe,eAAe,gBAAgB,oBAAoB,MAAM,0CAA0C,+BAA+B,aAAa,qBAAqB,mCAAmC,EAAE,EAAE,cAAc,WAAW,UAAU,EAAE,UAAU,MAAM,iDAAiD,EAAE,UAAU,kBAAkB,EAAE,EAAE,aAAa;;AAE1gB,+BAA+B,oCAAoC;;AAEnE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;;AAGA;AACA;AACA,qLAAqL;AACrL;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY;AACZ;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,C;;;;;;;;;;;;ACtGa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,cAAc,mBAAO,CAAC,8IAA2B;;AAEjD,sCAAsC,mBAAO,CAAC,8IAA2B;;AAEzE,uCAAuC,mBAAO,CAAC,mGAAgB;;AAE/D,qCAAqC,mBAAO,CAAC,+FAAc;;AAE3D,oCAAoC,mBAAO,CAAC,8GAAqB;;AAEjE,uCAAuC,mBAAO,CAAC,mGAAgB;;AAE/D,oBAAoB,mBAAO,CAAC,mHAAiB;;AAE7C,aAAa,mBAAO,CAAC,6FAAa;;AAElC,cAAc,mBAAO,CAAC,qGAAU;;AAEhC,cAAc,mBAAO,CAAC,2GAAS;;AAE/B,cAAc,mBAAO,CAAC,sHAAyB;;AAE/C,cAAc,mBAAO,CAAC,wHAA0B;;AAEhD,gBAAgB,mBAAO,CAAC,iHAAY;;AAEpC,sCAAsC,uCAAuC,kBAAkB;;AAE/F,uBAAuB,2EAA2E,kCAAkC,mBAAmB,GAAG,EAAE,OAAO,kCAAkC,8HAA8H,GAAG,EAAE,qBAAqB;;AAE7V,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE;;AAE3T,6DAA6D,sEAAsE,8DAA8D,oBAAoB;;AAErN,iDAAiD,0EAA0E,aAAa,EAAE,qCAAqC;;AAE/K,uCAAuC,uBAAuB,uFAAuF,EAAE,aAAa;;AAEpK,6BAA6B,gGAAgG,gDAAgD,GAAG,2BAA2B;;AAE3M,0CAA0C,+DAA+D,2EAA2E,EAAE,yEAAyE,eAAe,sDAAsD,EAAE,EAAE,uDAAuD;;AAE/X,gCAAgC,4EAA4E,iBAAiB,UAAU,GAAG,8BAA8B;;AAExK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,YAAY;AACvB,WAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,0CAA0C;AAC1C,iEAAiE;;AAEjE;AACA,4HAA4H;;AAE5H;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B;;;AAG5B,uCAAuC;;AAEvC;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;;AAEpC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,wCAAwC;;;AAGxC;AACA;AACA;AACA;AACA;AACA,wBAAwB;;AAExB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;;AAGL,mBAAmB;;;AAGnB;AACA;AACA;AACA,KAAK,EAAE;;AAEP,+BAA+B;;;AAG/B;AACA;AACA,MAAM;;AAEN,8BAA8B;;;AAG9B,8BAA8B;;;AAG9B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc;AACd;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+DAA+D;;AAE/D,4EAA4E;;AAE5E;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;;AAEA,uCAAuC,OAAO;AAC9C;AACA;;AAEA;;AAEA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,qEAAqE;;AAErE;AACA;AACA,QAAQ;;;AAGR;AACA,uFAAuF;;;AAGvF;AACA,QAAQ;;;AAGR;AACA;AACA;AACA;AACA;AACA,+CAA+C;;AAE/C;AACA;;AAEA,6CAA6C,OAAO;AACpD;AACA;;AAEA;;AAEA;;AAEA;AACA,0FAA0F;;AAE1F;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA,WAAW;;AAEX;AACA,SAAS;;;AAGT;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,QAAQ;;;AAGR;AACA;AACA;;AAEA,6CAA6C,OAAO;AACpD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,QAAQ;AACR;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA,mCAAmC;;AAEnC,4BAA4B;;AAE5B;;AAEA;AACA;AACA;AACA;;AAEA,6EAA6E;;AAE7E;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA,0EAA0E;;AAE1E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC;;AAEhC;AACA;AACA,OAAO;;AAEP,2CAA2C,WAAW;AACtD;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;;AAGP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,gGAAgG;;AAEhG,sFAAsF;;AAEtF;AACA;AACA;AACA;AACA,OAAO;;;AAGP;AACA,yCAAyC;;AAEzC;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;;AAGP,oBAAoB;;AAEpB,mBAAmB;;AAEnB,yCAAyC;;AAEzC,4IAA4I;;AAE5I;AACA;AACA;AACA;AACA,OAAO;AACP,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;;;AAGP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA,+CAA+C;;AAE/C;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;;;AAGP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE;;AAET;AACA;;AAEA,iDAAiD,OAAO;AACxD;;AAEA;AACA;AACA,wCAAwC;AACxC;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;;;AAGP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,6CAA6C;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,+CAA+C;AAC/C;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,yCAAyC;;AAEzC,uDAAuD;;AAEvD;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;AACA,wCAAwC;;AAExC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;;;AAGT;AACA;AACA,yCAAyC;;AAEzC;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,kDAAkD;;AAElD;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA,qCAAqC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA,2CAA2C;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA,GAAG;AACH;AACA;AACA,6BAA6B;;AAE7B,mEAAmE;;AAEnE;AACA,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;;AAElE;AACA;AACA;AACA;AACA;AACA,kCAAkC;;AAElC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;;AAGP;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED,mC;;;;;;;;;;;;ACjgCa;;AAEb;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACzEa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,sCAAsC,mBAAO,CAAC,yHAAW;;AAEzD,aAAa,mBAAO,CAAC,4GAAU;;AAE/B,wCAAwC,mBAAO,CAAC,8IAA4B;;AAE5E,wCAAwC,mBAAO,CAAC,8IAA4B;;AAE5E,sCAAsC,uCAAuC,kBAAkB;;AAE/F,uBAAuB,2EAA2E,kCAAkC,mBAAmB,GAAG,EAAE,OAAO,kCAAkC,8HAA8H,GAAG,EAAE,qBAAqB;;AAE7V,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE;;AAE3T,6DAA6D,sEAAsE,8DAA8D,oBAAoB;;AAErN,iDAAiD,0EAA0E,aAAa,EAAE,qCAAqC;;AAE/K,uCAAuC,uBAAuB,uFAAuF,EAAE,aAAa;;AAEpK,6BAA6B,gGAAgG,gDAAgD,GAAG,2BAA2B;;AAE3M,0CAA0C,+DAA+D,2EAA2E,EAAE,yEAAyE,eAAe,sDAAsD,EAAE,EAAE,uDAAuD;;AAE/X,gCAAgC,4EAA4E,iBAAiB,UAAU,GAAG,8BAA8B;;AAExK;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,yIAAyI;;AAEzI,kBAAkB;;AAElB,uBAAuB;;AAEvB,qCAAqC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,kDAAkD;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6HAA6H;;AAE7H;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,uDAAuD,QAAQ;AAC/D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;;AAErD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,uBAAuB;;AAEvB;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,6BAA6B;;AAE7B;AACA;AACA;AACA,4DAA4D;;AAE5D;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED,kC;;;;;;;;;;;;AC/La;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,eAAe,mBAAO,CAAC,yHAAW;;AAElC,oCAAoC,mBAAO,CAAC,qHAAS;;AAErD,mCAAmC,mBAAO,CAAC,mIAAgB;;AAE3D,sCAAsC,uCAAuC,kBAAkB;;AAE/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8B;;;;;;;;;;;;ACvBa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,sCAAsC,mBAAO,CAAC,yHAAW;;AAEzD,aAAa,mBAAO,CAAC,4GAAU;;AAE/B,8CAA8C,mBAAO,CAAC,4JAAmC;;AAEzF,uCAAuC,mBAAO,CAAC,4IAA2B;;AAE1E,sCAAsC,uCAAuC,kBAAkB;;AAE/F,uBAAuB,2EAA2E,kCAAkC,mBAAmB,GAAG,EAAE,OAAO,kCAAkC,8HAA8H,GAAG,EAAE,qBAAqB;;AAE7V,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE;;AAE3T,6DAA6D,sEAAsE,8DAA8D,oBAAoB;;AAErN,iDAAiD,0EAA0E,aAAa,EAAE,qCAAqC;;AAE/K,uCAAuC,uBAAuB,uFAAuF,EAAE,aAAa;;AAEpK,6BAA6B,gGAAgG,gDAAgD,GAAG,2BAA2B;;AAE3M,0CAA0C,+DAA+D,2EAA2E,EAAE,yEAAyE,eAAe,sDAAsD,EAAE,EAAE,uDAAuD;;AAE/X,gCAAgC,4EAA4E,iBAAiB,UAAU,GAAG,8BAA8B;;AAExK;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,oJAAoJ;;AAEpJ,kBAAkB;;AAElB;AACA,8BAA8B;;AAE9B;AACA,4CAA4C;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,uDAAuD,QAAQ;AAC/D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;;AAErD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,uBAAuB;;AAEvB,kEAAkE;;AAElE;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA,4DAA4D;;AAE5D;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED,wC;;;;;;;;;;;;AC5Na;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,sCAAsC,mBAAO,CAAC,yHAAW;;AAEzD,aAAa,mBAAO,CAAC,4GAAU;;AAE/B,uCAAuC,mBAAO,CAAC,4IAA2B;;AAE1E,uCAAuC,mBAAO,CAAC,4IAA2B;;AAE1E,sCAAsC,uCAAuC,kBAAkB;;AAE/F,uBAAuB,2EAA2E,kCAAkC,mBAAmB,GAAG,EAAE,OAAO,kCAAkC,8HAA8H,GAAG,EAAE,qBAAqB;;AAE7V,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE;;AAE3T,6DAA6D,sEAAsE,8DAA8D,oBAAoB;;AAErN,iDAAiD,0EAA0E,aAAa,EAAE,qCAAqC;;AAE/K,uCAAuC,uBAAuB,uFAAuF,EAAE,aAAa;;AAEpK,6BAA6B,gGAAgG,gDAAgD,GAAG,2BAA2B;;AAE3M,0CAA0C,+DAA+D,2EAA2E,EAAE,yEAAyE,eAAe,sDAAsD,EAAE,EAAE,uDAAuD;;AAE/X,gCAAgC,4EAA4E,iBAAiB,UAAU,GAAG,8BAA8B;;AAExK;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,sIAAsI;;AAEtI,kBAAkB;;AAElB;AACA,8BAA8B;;AAE9B;AACA,4CAA4C;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,uDAAuD,QAAQ;AAC/D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qDAAqD;;AAErD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;;AAE7B;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,uBAAuB;;AAEvB,kEAAkE;;AAElE;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA,4DAA4D;;AAE5D;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED,iC;;;;;;;;;;;;ACpNa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,sCAAsC,mBAAO,CAAC,yHAAW;;AAEzD,aAAa,mBAAO,CAAC,4GAAU;;AAE/B,2CAA2C,mBAAO,CAAC,sJAAgC;;AAEnF,2CAA2C,mBAAO,CAAC,sJAAgC;;AAEnF,sCAAsC,uCAAuC,kBAAkB;;AAE/F,uBAAuB,2EAA2E,kCAAkC,mBAAmB,GAAG,EAAE,OAAO,kCAAkC,8HAA8H,GAAG,EAAE,qBAAqB;;AAE7V,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE;;AAE3T,6DAA6D,sEAAsE,8DAA8D,oBAAoB;;AAErN,iDAAiD,0EAA0E,aAAa,EAAE,qCAAqC;;AAE/K,uCAAuC,uBAAuB,uFAAuF,EAAE,aAAa;;AAEpK,6BAA6B,gGAAgG,gDAAgD,GAAG,2BAA2B;;AAE3M,0CAA0C,+DAA+D,2EAA2E,EAAE,yEAAyE,eAAe,sDAAsD,EAAE,EAAE,uDAAuD;;AAE/X,gCAAgC,4EAA4E,iBAAiB,UAAU,GAAG,8BAA8B;;AAExK;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,kJAAkJ;;AAElJ,kBAAkB;;AAElB,uBAAuB;;AAEvB;AACA;AACA,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA;AACA,oEAAoE;;AAEpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED,qC;;;;;;;;;;;;ACzHa;;AAEb;AACA;AACA,CAAC;AACD;AACA;;AAEA,aAAa,mBAAO,CAAC,6HAAkB;;AAEvC,kCAAkC,iFAAiF;;AAEnH,+BAA+B,wEAAwE;;AAEvG,iCAAiC,+HAA+H;;AAEhK,kCAAkC,0BAA0B,8CAA8C,gBAAgB,OAAO,kBAAkB,EAAE,aAAa,EAAE;;AAEpK,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,2DAA2D,EAAE;;AAE3T,6DAA6D,sEAAsE,8DAA8D,oBAAoB;;AAErN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B,cAAc;AACd;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;;AAEP;AACA,KAAK;AACL;AACA,C;;;;;;;;;;;;AChIa;;AAEb;AACA;AACA,CAAC;AACD;AACA;;AAEA,oCAAoC,mBAAO,CAAC,2IAA4B;;AAExE,oCAAoC,mBAAO,CAAC,2IAA4B;;AAExE,wCAAwC,mBAAO,CAAC,qJAAiC;;AAEjF,mCAAmC,mBAAO,CAAC,sIAAsB;;AAEjE,mCAAmC,mBAAO,CAAC,4HAAiB;;AAE5D,oCAAoC,mBAAO,CAAC,wIAAuB;;AAEnE,sCAAsC,uCAAuC,kBAAkB;;AAE/F,uBAAuB,2EAA2E,kCAAkC,mBAAmB,GAAG,EAAE,OAAO,kCAAkC,8HAA8H,GAAG,EAAE,qBAAqB;;AAE7V;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,cAAc;AACxG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,0E;;;;;;;;;;;AC7EA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,gCAAgC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,kBAAkB;AAClF;AACA,yDAAyD,cAAc;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iCAAiC;AAClF,wHAAwH,mBAAmB,EAAE;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0BAA0B,EAAE;AAC/D,yCAAyC,eAAe;AACxD;AACA;AACA;AACA;AACA;AACA,8DAA8D,+DAA+D;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA,0CAA0C,yBAAyB,gCAAgC,qBAAqB,qEAAqE,wCAAwC,GAAG;;AAExO,OAAO;AACP,Y;;;;;;;;;;;AC9FA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,gCAAgC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,kBAAkB;AAClF;AACA,yDAAyD,cAAc;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iCAAiC;AAClF,wHAAwH,mBAAmB,EAAE;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0BAA0B,EAAE;AAC/D,yCAAyC,eAAe;AACxD;AACA;AACA;AACA;AACA;AACA,8DAA8D,+DAA+D;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,0BAA0B,8BAA8B,2BAA2B,yBAAyB,+BAA+B,8BAA8B,wBAAwB,wBAAwB,wBAAwB,yBAAyB,gCAAgC,mCAAmC,mCAAmC,iBAAiB,iCAAiC,+BAA+B,+BAA+B,sDAAsD,gDAAgD,wDAAwD,gDAAgD,gYAAgY,4BAA4B,6GAA6G,sBAAsB,wDAAwD,uCAAuC,iDAAiD,sBAAsB,GAAG;;AAEl6C,OAAO;AACP,Y;;;;;;;;;;;AC/FA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,gCAAgC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,kBAAkB;AAClF;AACA,yDAAyD,cAAc;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iCAAiC;AAClF,wHAAwH,mBAAmB,EAAE;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0BAA0B,EAAE;AAC/D,yCAAyC,eAAe;AACxD;AACA;AACA;AACA;AACA;AACA,8DAA8D,+DAA+D;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA,4CAA4C,0BAA0B,8BAA8B,yBAAyB,2BAA2B,8BAA8B,wBAAwB,wBAAwB,wBAAwB,yBAAyB,wBAAwB,4BAA4B,oCAAoC,mCAAmC,iBAAiB,oFAAoF,wDAAwD,2EAA2E,qIAAqI,mDAAmD,oFAAoF,8DAA8D,qCAAqC,yEAAyE,oGAAoG,qDAAqD,0DAA0D,gCAAgC,wDAAwD,0BAA0B,4BAA4B,iDAAiD,sBAAsB,GAAG;;AAE79C,OAAO;;AAEP,UAAU,E;;;;;;;;;;;AChGV;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,gCAAgC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,kBAAkB;AAClF;AACA,yDAAyD,cAAc;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iCAAiC;AAClF,wHAAwH,mBAAmB,EAAE;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0BAA0B,EAAE;AAC/D,yCAAyC,eAAe;AACxD;AACA;AACA;AACA;AACA;AACA,8DAA8D,+DAA+D;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA,0CAA0C,yBAAyB,wBAAwB,4BAA4B,8BAA8B,+CAA+C,qBAAqB,gDAAgD,yFAAyF,6CAA6C,GAAG;;AAElZ,OAAO;;AAEP,UAAU,E;;;;;;;;;;;AChGV;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,gCAAgC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,kBAAkB;AAClF;AACA,yDAAyD,cAAc;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iCAAiC;AAClF,wHAAwH,mBAAmB,EAAE;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0BAA0B,EAAE;AAC/D,yCAAyC,eAAe;AACxD;AACA;AACA;AACA;AACA;AACA,8DAA8D,+DAA+D;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA,4CAA4C,0BAA0B,8BAA8B,yBAAyB,8BAA8B,wBAAwB,wBAAwB,wBAAwB,yBAAyB,wBAAwB,4BAA4B,oCAAoC,mCAAmC,iBAAiB,oFAAoF,wDAAwD,2EAA2E,oGAAoG,0DAA0D,sBAAsB,wDAAwD,0BAA0B,4BAA4B,iDAAiD,sBAAsB,GAAG;;AAE38B,OAAO;;AAEP,UAAU,E;;;;;;;;;;;AChGV;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,gCAAgC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,kBAAkB;AAClF;AACA,yDAAyD,cAAc;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iCAAiC;AAClF,wHAAwH,mBAAmB,EAAE;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0BAA0B,EAAE;AAC/D,yCAAyC,eAAe;AACxD;AACA;AACA;AACA;AACA;AACA,8DAA8D,+DAA+D;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA,0CAA0C,yBAAyB,yBAAyB,6BAA6B,qBAAqB,2CAA2C,4CAA4C,oCAAoC,oBAAoB,sCAAsC,kDAAkD,gDAAgD,2CAA2C,GAAG;;AAEnd,OAAO;;AAEP,UAAU,E;;;;;;;;;;;AChGV;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,gCAAgC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,kBAAkB;AAClF;AACA,yDAAyD,cAAc;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iCAAiC;AAClF,wHAAwH,mBAAmB,EAAE;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0BAA0B,EAAE;AAC/D,yCAAyC,eAAe;AACxD;AACA;AACA;AACA;AACA;AACA,8DAA8D,+DAA+D;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA,4CAA4C,yBAAyB,yBAAyB,0BAA0B,wBAAwB,wBAAwB,yBAAyB,yBAAyB,qCAAqC,iBAAiB,wFAAwF,uLAAuL,kDAAkD,iDAAiD,sBAAsB,GAAG;;AAE3pB,OAAO;;AAEP,UAAU,E;;;;;;;;;;;;AChGG;;AAEb;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yEAAyE;;AAEzE,uCAAuC;;AAEvC,kCAAkC;;AAElC,2BAA2B;;AAE3B,8EAA8E;;AAE9E;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX,iCAAiC,OAAO;AACxC;AACA;;AAEA,0BAA0B;;AAE1B;;AAEA;AACA;AACA;AACA;;AAEA;AACA,C;;;;;;;;;;;;AChEa;;AAEb;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA,gBAAgB,mBAAO,CAAC,iHAAY;;AAEpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2IAA2I;;AAE3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,C;;;;;;;;;;;;AC5Ga;;AAEb;AACA;AACA,CAAC;AACD;AACA;;AAEA,uBAAuB,2EAA2E,kCAAkC,mBAAmB,GAAG,EAAE,OAAO,kCAAkC,8HAA8H,GAAG,EAAE,qBAAqB;;AAE7V;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY;AACZ;;;AAGA;AACA;;AAEA,uEAAuE,OAAO;AAC9E;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,C","file":"vendors~admin-components/group-dashboard.js","sourcesContent":["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = $getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  var args = [];\n  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    ReflectApply(this.listener, this.target, args);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _events = require(\"events\");\n\nvar easings = _interopRequireWildcard(require(\"./easings\"));\n\nvar _utils = require(\"./utils\");\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * Defaults.\n */\nvar ANIMATE_DEFAULTS = {\n  easing: 'quadraticInOut',\n  duration: 150\n};\nvar DEFAULT_ZOOMING_RATIO = 1.5; // TODO: animate options = number polymorphism?\n// TODO: pan, zoom, unzoom, reset, rotate, zoomTo\n// TODO: add width / height to camera and add #.resize\n// TODO: bind camera to renderer rather than sigma\n// TODO: add #.graphToDisplay, #.displayToGraph, batch methods later\n\n/**\n * Camera class\n *\n * @constructor\n */\n\nvar Camera =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inherits(Camera, _EventEmitter);\n\n  function Camera() {\n    var _this;\n\n    _classCallCheck(this, Camera);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Camera).call(this)); // Properties\n\n    _this.x = 0.5;\n    _this.y = 0.5;\n    _this.angle = 0;\n    _this.ratio = 1; // State\n\n    _this.nextFrame = null;\n    _this.previousState = _this.getState();\n    _this.enabled = true;\n    return _this;\n  }\n  /**\n   * Method used to enable the camera.\n   *\n   * @return {Camera}\n   */\n\n\n  _createClass(Camera, [{\n    key: \"enable\",\n    value: function enable() {\n      this.enabled = true;\n      return this;\n    }\n    /**\n     * Method used to disable the camera.\n     *\n     * @return {Camera}\n     */\n\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      this.enabled = false;\n      return this;\n    }\n    /**\n     * Method used to retrieve the camera's current state.\n     *\n     * @return {object}\n     */\n\n  }, {\n    key: \"getState\",\n    value: function getState() {\n      return {\n        x: this.x,\n        y: this.y,\n        angle: this.angle,\n        ratio: this.ratio\n      };\n    }\n    /**\n     * Method used to retrieve the camera's previous state.\n     *\n     * @return {object}\n     */\n\n  }, {\n    key: \"getPreviousState\",\n    value: function getPreviousState() {\n      var state = this.previousState;\n      return {\n        x: state.x,\n        y: state.y,\n        angle: state.angle,\n        ratio: state.ratio\n      };\n    }\n    /**\n     * Method used to check whether the camera is currently being animated.\n     *\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"isAnimated\",\n    value: function isAnimated() {\n      return !!this.nextFrame;\n    }\n    /**\n     * Method returning the coordinates of a point from the graph frame to the\n     * viewport.\n     *\n     * @param  {object} dimensions - Dimensions of the viewport.\n     * @param  {number} x          - The X coordinate.\n     * @param  {number} y          - The Y coordinate.\n     * @return {object}            - The point coordinates in the viewport.\n     */\n    // TODO: assign to gain one object\n    // TODO: angles\n\n  }, {\n    key: \"graphToViewport\",\n    value: function graphToViewport(dimensions, x, y) {\n      var smallestDimension = Math.min(dimensions.width, dimensions.height);\n      var dx = smallestDimension / dimensions.width,\n          dy = smallestDimension / dimensions.height; // TODO: we keep on the upper left corner!\n      // TODO: how to normalize sizes?\n\n      return {\n        x: (x - this.x + this.ratio / 2 / dx) * (smallestDimension / this.ratio),\n        y: (this.y - y + this.ratio / 2 / dy) * (smallestDimension / this.ratio)\n      };\n    }\n    /**\n     * Method returning the coordinates of a point from the viewport frame to the\n     * graph frame.\n     *\n     * @param  {object} dimensions - Dimensions of the viewport.\n     * @param  {number} x          - The X coordinate.\n     * @param  {number} y          - The Y coordinate.\n     * @return {object}            - The point coordinates in the graph frame.\n     */\n    // TODO: angles\n\n  }, {\n    key: \"viewportToGraph\",\n    value: function viewportToGraph(dimensions, x, y) {\n      var smallestDimension = Math.min(dimensions.width, dimensions.height);\n      var dx = smallestDimension / dimensions.width,\n          dy = smallestDimension / dimensions.height;\n      return {\n        x: this.ratio / smallestDimension * x + this.x - this.ratio / 2 / dx,\n        y: -(this.ratio / smallestDimension * y - this.y - this.ratio / 2 / dy)\n      };\n    }\n    /**\n     * Method returning the abstract rectangle containing the graph according\n     * to the camera's state.\n     *\n     * @return {object} - The view's rectangle.\n     */\n    // TODO: angle\n\n  }, {\n    key: \"viewRectangle\",\n    value: function viewRectangle(dimensions) {\n      // TODO: reduce relative margin?\n      var marginX = 0 * dimensions.width / 8,\n          marginY = 0 * dimensions.height / 8;\n      var p1 = this.viewportToGraph(dimensions, 0 - marginX, 0 - marginY),\n          p2 = this.viewportToGraph(dimensions, dimensions.width + marginX, 0 - marginY),\n          h = this.viewportToGraph(dimensions, 0, dimensions.height + marginY);\n      return {\n        x1: p1.x,\n        y1: p1.y,\n        x2: p2.x,\n        y2: p2.y,\n        height: p2.y - h.y\n      };\n    }\n    /**\n     * Method used to set the camera's state.\n     *\n     * @param  {object} state - New state.\n     * @return {Camera}\n     */\n\n  }, {\n    key: \"setState\",\n    value: function setState(state) {\n      if (!this.enabled) return this; // TODO: validations\n      // TODO: update by function\n      // Keeping track of last state\n\n      this.previousState = this.getState();\n      if ('x' in state) this.x = state.x;\n      if ('y' in state) this.y = state.y;\n      if ('angle' in state) this.angle = state.angle;\n      if ('ratio' in state) this.ratio = state.ratio; // Emitting\n      // TODO: don't emit if nothing changed?\n\n      this.emit('updated', this.getState());\n      return this;\n    }\n    /**\n     * Method used to animate the camera.\n     *\n     * @param  {object}   state      - State to reach eventually.\n     * @param  {object}   options    - Options:\n     * @param  {number}     duration - Duration of the animation.\n     * @param  {function} callback   - Callback\n     * @return {function}            - Return a function to cancel the animation.\n     */\n\n  }, {\n    key: \"animate\",\n    value: function animate(state, options, callback) {\n      var _this2 = this;\n\n      if (!this.enabled) return this; // TODO: validation\n\n      options = (0, _utils.assign)({}, ANIMATE_DEFAULTS, options);\n      var easing = typeof options.easing === 'function' ? options.easing : easings[options.easing]; // Canceling previous animation if needed\n\n      if (this.nextFrame) cancelAnimationFrame(this.nextFrame); // State\n\n      var start = Date.now(),\n          initialState = this.getState(); // Function performing the animation\n\n      var fn = function fn() {\n        var t = (Date.now() - start) / options.duration; // The animation is over:\n\n        if (t >= 1) {\n          _this2.nextFrame = null;\n\n          _this2.setState(state);\n\n          if (typeof callback === 'function') callback();\n          return;\n        }\n\n        var coefficient = easing(t);\n        var newState = {};\n        if ('x' in state) newState.x = initialState.x + (state.x - initialState.x) * coefficient;\n        if ('y' in state) newState.y = initialState.y + (state.y - initialState.y) * coefficient;\n        if ('angle' in state) newState.angle = initialState.angle + (state.angle - initialState.angle) * coefficient;\n        if ('ratio' in state) newState.ratio = initialState.ratio + (state.ratio - initialState.ratio) * coefficient;\n\n        _this2.setState(newState);\n\n        _this2.nextFrame = requestAnimationFrame(fn);\n      };\n\n      if (this.nextFrame) {\n        cancelAnimationFrame(this.nextFrame);\n        this.nextFrame = requestAnimationFrame(fn);\n      } else {\n        fn();\n      }\n    }\n    /**\n     * Method used to zoom the camera.\n     *\n     * @param  {number|object} factorOrOptions - Factor or options.\n     * @return {function}\n     */\n\n  }, {\n    key: \"animatedZoom\",\n    value: function animatedZoom(factorOrOptions) {\n      if (!factorOrOptions) {\n        return this.animate({\n          ratio: this.ratio / DEFAULT_ZOOMING_RATIO\n        });\n      } else {\n        if (typeof factorOrOptions === 'number') return this.animate({\n          ratio: this.ratio / factorOrOptions\n        });else return this.animate({\n          ratio: this.ratio / (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO)\n        }, factorOrOptions);\n      }\n    }\n    /**\n     * Method used to unzoom the camera.\n     *\n     * @param  {number|object} factorOrOptions - Factor or options.\n     * @return {function}\n     */\n\n  }, {\n    key: \"animatedUnzoom\",\n    value: function animatedUnzoom(factorOrOptions) {\n      if (!factorOrOptions) {\n        return this.animate({\n          ratio: this.ratio * DEFAULT_ZOOMING_RATIO\n        });\n      } else {\n        if (typeof factorOrOptions === 'number') return this.animate({\n          ratio: this.ratio * factorOrOptions\n        });else return this.animate({\n          ratio: this.ratio * (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO)\n        }, factorOrOptions);\n      }\n    }\n    /**\n     * Method used to reset the camera.\n     *\n     * @param  {object} options - Options.\n     * @return {function}\n     */\n\n  }, {\n    key: \"animatedReset\",\n    value: function animatedReset(options) {\n      return this.animate({\n        x: 0.5,\n        y: 0.5,\n        ratio: 1,\n        angle: 0\n      }, options);\n    }\n  }]);\n\n  return Camera;\n}(_events.EventEmitter);\n\nexports[\"default\"] = Camera;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _events = require(\"events\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Captor =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inherits(Captor, _EventEmitter);\n\n  function Captor(container, camera) {\n    var _this;\n\n    _classCallCheck(this, Captor);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Captor).call(this)); // Properties\n\n    _this.container = container;\n    _this.camera = camera;\n    return _this;\n  }\n\n  return Captor;\n}(_events.EventEmitter);\n\nexports[\"default\"] = Captor;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _camera = _interopRequireDefault(require(\"../camera\"));\n\nvar _captor = _interopRequireDefault(require(\"../captor\"));\n\nvar _utils = require(\"./utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * Constants.\n */\nvar DRAG_TIMEOUT = 200,\n    MOUSE_INERTIA_DURATION = 200,\n    MOUSE_INERTIA_RATIO = 3,\n    MOUSE_ZOOM_DURATION = 200,\n    ZOOMING_RATIO = 1.7,\n    DOUBLE_CLICK_TIMEOUT = 300,\n    DOUBLE_CLICK_ZOOMING_RATIO = 2.2,\n    DOUBLE_CLICK_ZOOMING_DURATION = 200;\n/**\n * Mouse captor class.\n *\n * @constructor\n */\n\nvar MouseCaptor =\n/*#__PURE__*/\nfunction (_Captor) {\n  _inherits(MouseCaptor, _Captor);\n\n  function MouseCaptor(container, camera) {\n    var _this;\n\n    _classCallCheck(this, MouseCaptor);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MouseCaptor).call(this, container, camera)); // Properties\n\n    _this.container = container;\n    _this.camera = camera; // State\n\n    _this.enabled = true;\n    _this.hasDragged = false;\n    _this.downStartTime = null;\n    _this.lastMouseX = null;\n    _this.lastMouseY = null;\n    _this.isMouseDown = false;\n    _this.isMoving = false;\n    _this.movingTimeout = null;\n    _this.startCameraState = null;\n    _this.lastCameraState = null;\n    _this.clicks = 0;\n    _this.doubleClickTimeout = null;\n    _this.wheelLock = false; // Binding methods\n\n    _this.handleClick = _this.handleClick.bind(_assertThisInitialized(_this));\n    _this.handleDown = _this.handleDown.bind(_assertThisInitialized(_this));\n    _this.handleUp = _this.handleUp.bind(_assertThisInitialized(_this));\n    _this.handleMove = _this.handleMove.bind(_assertThisInitialized(_this));\n    _this.handleWheel = _this.handleWheel.bind(_assertThisInitialized(_this));\n    _this.handleOut = _this.handleOut.bind(_assertThisInitialized(_this)); // Binding events\n\n    container.addEventListener('click', _this.handleClick, false);\n    container.addEventListener('mousedown', _this.handleDown, false);\n    container.addEventListener('mousemove', _this.handleMove, false);\n    container.addEventListener('DOMMouseScroll', _this.handleWheel, false);\n    container.addEventListener('mousewheel', _this.handleWheel, false);\n    container.addEventListener('mouseout', _this.handleOut, false);\n    document.addEventListener('mouseup', _this.handleUp, false);\n    return _this;\n  }\n\n  _createClass(MouseCaptor, [{\n    key: \"kill\",\n    value: function kill() {\n      var container = this.container;\n      container.removeEventListener('click', this.handleClick);\n      container.removeEventListener('mousedown', this.handleDown);\n      container.removeEventListener('mousemove', this.handleMove);\n      container.removeEventListener('DOMMouseScroll', this.handleWheel);\n      container.removeEventListener('mousewheel', this.handleWheel);\n      container.removeEventListener('mouseout', this.handleOut);\n      document.removeEventListener('mouseup', this.handleUp);\n    }\n  }, {\n    key: \"handleClick\",\n    value: function handleClick(e) {\n      var _this2 = this;\n\n      if (!this.enabled) return;\n      this.clicks++;\n\n      if (this.clicks === 2) {\n        this.clicks = 0;\n        clearTimeout(this.doubleClickTimeout);\n        this.doubleClickTimeout = null;\n        return this.handleDoubleClick(e);\n      }\n\n      setTimeout(function () {\n        _this2.clicks = 0;\n        _this2.doubleClickTimeout = null;\n      }, DOUBLE_CLICK_TIMEOUT); // NOTE: this is here to prevent click events on drag\n\n      if (!this.hasDragged) this.emit('click', (0, _utils.getMouseCoords)(e));\n    }\n  }, {\n    key: \"handleDoubleClick\",\n    value: function handleDoubleClick(e) {\n      if (!this.enabled) return;\n      var center = (0, _utils.getCenter)(e);\n      var cameraState = this.camera.getState();\n      var newRatio = cameraState.ratio / DOUBLE_CLICK_ZOOMING_RATIO; // TODO: factorize\n\n      var dimensions = {\n        width: this.container.offsetWidth,\n        height: this.container.offsetHeight\n      };\n      var clickX = (0, _utils.getX)(e),\n          clickY = (0, _utils.getY)(e); // TODO: baaaad we mustn't mutate the camera, create a Camera.from or #.copy\n      // TODO: factorize pan & zoomTo\n\n      var cameraWithNewRatio = new _camera[\"default\"]();\n      cameraWithNewRatio.ratio = newRatio;\n      cameraWithNewRatio.x = cameraState.x;\n      cameraWithNewRatio.y = cameraState.y;\n      var clickGraph = this.camera.viewportToGraph(dimensions, clickX, clickY),\n          centerGraph = this.camera.viewportToGraph(dimensions, center.x, center.y);\n      var clickGraphNew = cameraWithNewRatio.viewportToGraph(dimensions, clickX, clickY),\n          centerGraphNew = cameraWithNewRatio.viewportToGraph(dimensions, center.x, center.y);\n      var deltaX = clickGraphNew.x - centerGraphNew.x - clickGraph.x + centerGraph.x,\n          deltaY = clickGraphNew.y - centerGraphNew.y - clickGraph.y + centerGraph.y;\n      this.camera.animate({\n        x: cameraState.x - deltaX,\n        y: cameraState.y - deltaY,\n        ratio: newRatio\n      }, {\n        easing: 'quadraticInOut',\n        duration: DOUBLE_CLICK_ZOOMING_DURATION\n      });\n      if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n      e.stopPropagation();\n      return false;\n    }\n  }, {\n    key: \"handleDown\",\n    value: function handleDown(e) {\n      if (!this.enabled) return;\n      this.startCameraState = this.camera.getState();\n      this.lastCameraState = this.startCameraState;\n      this.lastMouseX = (0, _utils.getX)(e);\n      this.lastMouseY = (0, _utils.getY)(e);\n      this.hasDragged = false;\n      this.downStartTime = Date.now(); // TODO: dispatch events\n\n      switch (e.which) {\n        default:\n          // Left button pressed\n          this.isMouseDown = true;\n          this.emit('mousedown', (0, _utils.getMouseCoords)(e));\n      }\n    }\n  }, {\n    key: \"handleUp\",\n    value: function handleUp(e) {\n      var _this3 = this;\n\n      if (!this.enabled || !this.isMouseDown) return;\n      this.isMouseDown = false;\n\n      if (this.movingTimeout) {\n        this.movingTimeout = null;\n        clearTimeout(this.movingTimeout);\n      }\n\n      var x = (0, _utils.getX)(e),\n          y = (0, _utils.getY)(e);\n      var cameraState = this.camera.getState(),\n          previousCameraState = this.camera.getPreviousState();\n\n      if (this.isMoving) {\n        this.camera.animate({\n          x: cameraState.x + MOUSE_INERTIA_RATIO * (cameraState.x - previousCameraState.x),\n          y: cameraState.y + MOUSE_INERTIA_RATIO * (cameraState.y - previousCameraState.y)\n        }, {\n          duration: MOUSE_INERTIA_DURATION,\n          easing: 'quadraticOut'\n        });\n      } else if (this.lastMouseX !== x || this.lastMouseY !== y) {\n        this.camera.setState({\n          x: cameraState.x,\n          y: cameraState.y\n        });\n      }\n\n      this.isMoving = false;\n      setImmediate(function () {\n        return _this3.hasDragged = false;\n      });\n      this.emit('mouseup', (0, _utils.getMouseCoords)(e));\n    }\n  }, {\n    key: \"handleMove\",\n    value: function handleMove(e) {\n      var _this4 = this;\n\n      if (!this.enabled) return;\n      this.emit('mousemove', (0, _utils.getMouseCoords)(e));\n\n      if (this.isMouseDown) {\n        // TODO: dispatch events\n        this.isMoving = true;\n        this.hasDragged = true;\n        if (this.movingTimeout) clearTimeout(this.movingTimeout);\n        this.movingTimeout = setTimeout(function () {\n          _this4.movingTimeout = null;\n          _this4.isMoving = false;\n        }, DRAG_TIMEOUT);\n        var dimensions = {\n          width: this.container.offsetWidth,\n          height: this.container.offsetHeight\n        };\n        var eX = (0, _utils.getX)(e),\n            eY = (0, _utils.getY)(e);\n        var lastMouse = this.camera.viewportToGraph(dimensions, this.lastMouseX, this.lastMouseY);\n        var mouse = this.camera.viewportToGraph(dimensions, eX, eY);\n        var offsetX = lastMouse.x - mouse.x,\n            offsetY = lastMouse.y - mouse.y;\n        var cameraState = this.camera.getState();\n        var x = cameraState.x + offsetX,\n            y = cameraState.y + offsetY;\n        this.camera.setState({\n          x: x,\n          y: y\n        });\n        this.lastMouseX = eX;\n        this.lastMouseY = eY;\n      }\n\n      if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n      e.stopPropagation();\n      return false;\n    }\n  }, {\n    key: \"handleWheel\",\n    value: function handleWheel(e) {\n      var _this5 = this;\n\n      if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n      e.stopPropagation();\n      if (!this.enabled) return false;\n      var delta = (0, _utils.getWheelDelta)(e);\n      if (!delta) return false;\n      if (this.wheelLock) return false;\n      this.wheelLock = true; // TODO: handle max zoom\n\n      var ratio = delta > 0 ? 1 / ZOOMING_RATIO : ZOOMING_RATIO;\n      var cameraState = this.camera.getState();\n      var newRatio = ratio * cameraState.ratio;\n      var center = (0, _utils.getCenter)(e);\n      var dimensions = {\n        width: this.container.offsetWidth,\n        height: this.container.offsetHeight\n      };\n      var clickX = (0, _utils.getX)(e),\n          clickY = (0, _utils.getY)(e); // TODO: baaaad we mustn't mutate the camera, create a Camera.from or #.copy\n      // TODO: factorize pan & zoomTo\n\n      var cameraWithNewRatio = new _camera[\"default\"]();\n      cameraWithNewRatio.ratio = newRatio;\n      cameraWithNewRatio.x = cameraState.x;\n      cameraWithNewRatio.y = cameraState.y;\n      var clickGraph = this.camera.viewportToGraph(dimensions, clickX, clickY),\n          centerGraph = this.camera.viewportToGraph(dimensions, center.x, center.y);\n      var clickGraphNew = cameraWithNewRatio.viewportToGraph(dimensions, clickX, clickY),\n          centerGraphNew = cameraWithNewRatio.viewportToGraph(dimensions, center.x, center.y);\n      var deltaX = clickGraphNew.x - centerGraphNew.x - clickGraph.x + centerGraph.x,\n          deltaY = clickGraphNew.y - centerGraphNew.y - clickGraph.y + centerGraph.y;\n      this.camera.animate({\n        x: cameraState.x - deltaX,\n        y: cameraState.y - deltaY,\n        ratio: newRatio\n      }, {\n        easing: 'linear',\n        duration: MOUSE_ZOOM_DURATION\n      }, function () {\n        return _this5.wheelLock = false;\n      });\n      return false;\n    }\n  }, {\n    key: \"handleOut\",\n    value: function handleOut() {// TODO: dispatch event\n    }\n  }]);\n\n  return MouseCaptor;\n}(_captor[\"default\"]);\n\nexports[\"default\"] = MouseCaptor;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getX = getX;\nexports.getY = getY;\nexports.getWidth = getWidth;\nexports.getHeight = getHeight;\nexports.getCenter = getCenter;\nexports.getMouseCoords = getMouseCoords;\nexports.getWheelDelta = getWheelDelta;\n\nvar _utils = require(\"../renderers/utils\");\n\n/**\n * Sigma.js Captor Utils\n * ======================\n *\n * Miscellenous helper functions related to the captors.\n */\n\n/**\n * Extract the local X position from a mouse or touch event.\n *\n * @param  {event}  e - A mouse or touch event.\n * @return {number}     The local X value of the mouse.\n */\nfunction getX(e) {\n  if (typeof e.offsetX !== 'undefined') return e.offsetX;\n  if (typeof e.layerX !== 'undefined') return e.layerX;\n  if (typeof e.clientX !== 'undefined') return e.clientX;\n  throw new Error('sigma/captors/utils.getX: could not extract x from event.');\n}\n/**\n * Extract the local Y position from a mouse or touch event.\n *\n * @param  {event}  e - A mouse or touch event.\n * @return {number}     The local Y value of the mouse.\n */\n\n\nfunction getY(e) {\n  if (typeof e.offsetY !== 'undefined') return e.offsetY;\n  if (typeof e.layerY !== 'undefined') return e.layerY;\n  if (typeof e.clientY !== 'undefined') return e.clientY;\n  throw new Error('sigma/captors/utils.getY: could not extract y from event.');\n}\n/**\n * Extract the width from a mouse or touch event.\n *\n * @param  {event}  e - A mouse or touch event.\n * @return {number}     The width of the event's target.\n */\n\n\nfunction getWidth(e) {\n  var w = !e.target.ownerSVGElement ? e.target.width : e.target.ownerSVGElement.width;\n  if (typeof w === 'number') return w;\n  if (w !== undefined && w.baseVal !== undefined) return w.baseVal.value;\n  throw new Error('sigma/captors/utils.getWidth: could not extract width from event.');\n}\n/**\n * Extract the height from a mouse or touch event.\n *\n * @param  {event}  e - A mouse or touch event.\n * @return {number}     The height of the event's target.\n */\n\n\nfunction getHeight(e) {\n  var w = !e.target.ownerSVGElement ? e.target.height : e.target.ownerSVGElement.height;\n  if (typeof w === 'number') return w;\n  if (w !== undefined && w.baseVal !== undefined) return w.baseVal.value;\n  throw new Error('sigma/captors/utils.getHeight: could not extract height from event.');\n}\n/**\n * Extract the center from a mouse or touch event.\n *\n * @param  {event}  e - A mouse or touch event.\n * @return {object}     The center of the event's target.\n */\n\n\nfunction getCenter(e) {\n  var ratio = e.target.namespaceURI.indexOf('svg') !== -1 ? 1 : (0, _utils.getPixelRatio)();\n  return {\n    x: getWidth(e) / (2 * ratio),\n    y: getHeight(e) / (2 * ratio)\n  };\n}\n/**\n * Convert mouse coords to sigma coords.\n *\n * @param  {event}   e   - A mouse or touch event.\n * @param  {number}  [x] - The x coord to convert\n * @param  {number}  [y] - The y coord to convert\n *\n * @return {object}\n */\n\n\nfunction getMouseCoords(e) {\n  return {\n    x: getX(e),\n    y: getY(e),\n    clientX: e.clientX,\n    clientY: e.clientY,\n    ctrlKey: e.ctrlKey,\n    metaKey: e.metaKey,\n    altKey: e.altKey,\n    shiftKey: e.shiftKey\n  };\n}\n/**\n * Extract the wheel delta from a mouse or touch event.\n *\n * @param  {event}  e - A mouse or touch event.\n * @return {number}     The wheel delta of the mouse.\n */\n\n\nfunction getWheelDelta(e) {\n  if (typeof e.wheelDelta !== 'undefined') return e.wheelDelta / 360;\n  if (typeof e.detail !== 'undefined') return e.detail / -9;\n  throw new Error('sigma/captors/utils.getDelta: could not extract delta from event.');\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cubicInOut = exports.cubicOut = exports.cubicIn = exports.quadraticInOut = exports.quadraticOut = exports.quadraticIn = exports.linear = void 0;\n\n/**\n * Sigma.js Easings\n * =================\n *\n * Handy collection of easing functions.\n */\nvar linear = function linear(k) {\n  return k;\n};\n\nexports.linear = linear;\n\nvar quadraticIn = function quadraticIn(k) {\n  return k * k;\n};\n\nexports.quadraticIn = quadraticIn;\n\nvar quadraticOut = function quadraticOut(k) {\n  return k * (2 - k);\n};\n\nexports.quadraticOut = quadraticOut;\n\nvar quadraticInOut = function quadraticInOut(k) {\n  if ((k *= 2) < 1) return 0.5 * k * k;\n  return -0.5 * (--k * (k - 2) - 1);\n};\n\nexports.quadraticInOut = quadraticInOut;\n\nvar cubicIn = function cubicIn(k) {\n  return k * k * k;\n};\n\nexports.cubicIn = cubicIn;\n\nvar cubicOut = function cubicOut(k) {\n  return --k * k * k + 1;\n};\n\nexports.cubicOut = cubicOut;\n\nvar cubicInOut = function cubicInOut(k) {\n  if ((k *= 2) < 1) return 0.5 * k * k * k;\n  return 0.5 * ((k -= 2) * k * k + 2);\n};\n\nexports.cubicInOut = cubicInOut;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"Renderer\", {\n  enumerable: true,\n  get: function get() {\n    return _renderer[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"Camera\", {\n  enumerable: true,\n  get: function get() {\n    return _camera[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"QuadTree\", {\n  enumerable: true,\n  get: function get() {\n    return _quadtree[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"MouseCaptor\", {\n  enumerable: true,\n  get: function get() {\n    return _mouse[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"WebGLRenderer\", {\n  enumerable: true,\n  get: function get() {\n    return _webgl[\"default\"];\n  }\n});\n\nvar _renderer = _interopRequireDefault(require(\"./renderer\"));\n\nvar _camera = _interopRequireDefault(require(\"./camera\"));\n\nvar _quadtree = _interopRequireDefault(require(\"./quadtree\"));\n\nvar _mouse = _interopRequireDefault(require(\"./captors/mouse\"));\n\nvar _webgl = _interopRequireDefault(require(\"./renderers/webgl\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.labelsToDisplayFromGrid = labelsToDisplayFromGrid;\nexports.edgeLabelsToDisplayFromNodes = edgeLabelsToDisplayFromNodes;\n\nvar _camera = _interopRequireDefault(require(\"../camera\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/**\n * Sigma.js Labels Heuristics\n * ===========================\n *\n * Miscelleneous heuristics related to label display.\n */\n\n/**\n * Constants.\n */\n// Dimensions of a normal cell\nvar DEFAULT_CELL = {\n  width: 250,\n  height: 175\n}; // Dimensions of an unzoomed cell. This one is usually larger than the normal\n// one to account for the fact that labels will more likely collide.\n\nvar DEFAULT_UNZOOMED_CELL = {\n  width: 400,\n  height: 300\n};\n/**\n * Helpers.\n */\n\nfunction collision(x1, y1, w1, h1, x2, y2, w2, h2) {\n  return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;\n} // TODO: cache camera position of selected nodes to avoid costly computations\n// in anti-collision step\n// TOOD: document a little bit more so future people can understand this mess\n\n/**\n * Label grid heuristic selecting labels to display.\n *\n * @param  {object} params                 - Parameters:\n * @param  {object}   cache                - Cache storing nodes' data.\n * @param  {Camera}   camera               - The renderer's camera.\n * @param  {Set}      displayedLabels      - Currently displayed labels.\n * @param  {Array}    visibleNodes         - Nodes visible for this render.\n * @param  {Graph}    graph                - The rendered graph.\n * @return {Array}                         - The selected labels.\n */\n\n\nfunction labelsToDisplayFromGrid(params) {\n  var cache = params.cache,\n      camera = params.camera,\n      userCell = params.cell,\n      dimensions = params.dimensions,\n      displayedLabels = params.displayedLabels,\n      _params$fontSize = params.fontSize,\n      fontSize = _params$fontSize === void 0 ? 14 : _params$fontSize,\n      graph = params.graph,\n      _params$renderedSizeT = params.renderedSizeThreshold,\n      renderedSizeThreshold = _params$renderedSizeT === void 0 ? -Infinity : _params$renderedSizeT,\n      visibleNodes = params.visibleNodes;\n  var cameraState = camera.getState(),\n      previousCameraState = camera.getPreviousState();\n  var previousCamera = new _camera[\"default\"]();\n  previousCamera.setState(previousCameraState); // TODO: should factorize. This same code is used quite a lot throughout the codebase\n  // TODO: POW RATIO is currently default 0.5 and harcoded\n\n  var sizeRatio = Math.pow(cameraState.ratio, 0.5); // Camera hasn't moved?\n\n  var still = cameraState.x === previousCameraState.x && cameraState.y === previousCameraState.y && cameraState.ratio === previousCameraState.ratio; // State\n\n  var zooming = cameraState.ratio < previousCameraState.ratio,\n      panning = cameraState.x !== previousCameraState.x || cameraState.y !== previousCameraState.y,\n      unzooming = cameraState.ratio > previousCameraState.ratio,\n      unzoomedPanning = !zooming && !unzooming && cameraState.ratio >= 1,\n      zoomedPanning = panning && displayedLabels.size && !zooming && !unzooming; // Trick to discretize unzooming\n\n  if (unzooming && Math.trunc(cameraState.ratio * 100) % 5 !== 0) return Array.from(displayedLabels); // If panning while unzoomed, we shouldn't change label selection\n\n  if ((unzoomedPanning || still) && displayedLabels.size !== 0) return Array.from(displayedLabels); // When unzoomed & zooming\n\n  if (zooming && cameraState.ratio >= 1) return Array.from(displayedLabels); // Adapting cell dimensions\n\n  var cell = userCell ? userCell : DEFAULT_CELL;\n  if (cameraState.ratio >= 1.3) cell = DEFAULT_UNZOOMED_CELL;\n  var cwr = dimensions.width % cell.width;\n  var cellWidth = cell.width + cwr / Math.floor(dimensions.width / cell.width);\n  var chr = dimensions.height % cell.height;\n  var cellHeight = cell.height + chr / Math.floor(dimensions.height / cell.height);\n  var adjustedWidth = dimensions.width + cellWidth,\n      adjustedHeight = dimensions.height + cellHeight,\n      adjustedX = -cellWidth,\n      adjustedY = -cellHeight;\n  var panningWidth = dimensions.width + cellWidth / 2,\n      panningHeight = dimensions.height + cellHeight / 2,\n      panningX = -(cellWidth / 2),\n      panningY = -(cellHeight / 2); // console.log(cellWidth, cellHeight, dimensions.width / cellWidth, dimensions.height / cellHeight);\n\n  var worthyLabels = [];\n  var grid = {};\n  var maxSize = -Infinity,\n      biggestNode = null;\n\n  for (var i = 0, l = visibleNodes.length; i < l; i++) {\n    var node = visibleNodes[i],\n        nodeData = cache[node]; // We filter nodes having a rendered size less than a certain thresold\n\n    if (nodeData.size / sizeRatio < renderedSizeThreshold) continue; // Finding our node's cell in the grid\n\n    var pos = camera.graphToViewport(dimensions, nodeData.x, nodeData.y); // Node is not actually visible on screen\n    // NOTE: can optimize margin on the right side (only if we know where the labels go)\n\n    if (pos.x < adjustedX || pos.x > adjustedWidth || pos.y < adjustedY || pos.y > adjustedHeight) continue; // Keeping track of the maximum node size for certain cases\n\n    if (nodeData.size > maxSize) {\n      maxSize = nodeData.size;\n      biggestNode = node;\n    } // If panning when zoomed, we consider only displayed labels and newly\n    // visible nodes\n\n\n    if (zoomedPanning) {\n      var ppos = previousCamera.graphToViewport(dimensions, nodeData.x, nodeData.y); // Was node visible earlier?\n\n      if (ppos.x >= panningX && ppos.x <= panningWidth && ppos.y >= panningY && ppos.y <= panningHeight) {\n        // Was the label displayed?\n        if (!displayedLabels.has(node)) continue;\n      }\n    }\n\n    var xKey = Math.floor(pos.x / cellWidth),\n        yKey = Math.floor(pos.y / cellHeight);\n    var key = \"\".concat(xKey, \"\\xA7\").concat(yKey);\n\n    if (typeof grid[key] === 'undefined') {\n      // This cell is not yet occupied\n      grid[key] = node;\n    } else {\n      // We must solve a conflict in this cell\n      var currentNode = grid[key],\n          currentNodeData = cache[currentNode]; // We prefer already displayed labels\n\n      if (displayedLabels.size > 0) {\n        var n1 = displayedLabels.has(node),\n            n2 = displayedLabels.has(currentNode);\n\n        if (!n1 && n2) {\n          continue;\n        }\n\n        if (n1 && !n2) {\n          grid[key] = node;\n          continue;\n        }\n\n        if ((zoomedPanning || zooming) && n1 && n2) {\n          worthyLabels.push(node);\n          continue;\n        }\n      } // In case of size & degree equality, we use the node's key so that the\n      // process remains deterministic\n\n\n      var won = false;\n\n      if (nodeData.size > currentNodeData.size) {\n        won = true;\n      } else if (nodeData.size === currentNodeData.size) {\n        var nodeDegree = graph.degree(node),\n            currentNodeDegree = graph.degree(currentNode);\n\n        if (nodeDegree > currentNodeDegree) {\n          won = true;\n        } else if (nodeDegree === currentNodeDegree) {\n          if (node > currentNode) won = true;\n        }\n      }\n\n      if (won) grid[key] = node;\n    }\n  } // Compiling the labels\n\n\n  var biggestNodeShown = worthyLabels.some(function (node) {\n    return node === biggestNode;\n  });\n\n  for (var _key in grid) {\n    var _node = grid[_key];\n    if (_node === biggestNode) biggestNodeShown = true;\n    worthyLabels.push(_node);\n  } // Always keeping biggest node shown on screen\n\n\n  if (!biggestNodeShown && biggestNode) worthyLabels.push(biggestNode); // Basic anti-collision\n\n  var collisions = new Set();\n\n  for (var _i = 0, _l = worthyLabels.length; _i < _l; _i++) {\n    var _n = worthyLabels[_i],\n        d1 = cache[_n],\n        p1 = camera.graphToViewport(dimensions, d1.x, d1.y);\n    if (collisions.has(_n)) continue;\n\n    for (var j = _i + 1; j < _l; j++) {\n      var _n2 = worthyLabels[j],\n          d2 = cache[_n2],\n          p2 = camera.graphToViewport(dimensions, d2.x, d2.y);\n      var c = collision( // First abstract bbox\n      p1.x, p1.y, d1.label.length * 8, fontSize, // Second abstract bbox\n      p2.x, p2.y, d2.label.length * 8, fontSize);\n\n      if (c) {\n        // NOTE: add degree as tie-breaker here if required in the future\n        // NOTE: add final stable tie-breaker using node key if required\n        if (d1.size < d2.size) collisions.add(_n);else collisions.add(_n2);\n      }\n    }\n  } // console.log(collisions)\n\n\n  return worthyLabels.filter(function (l) {\n    return !collisions.has(l);\n  });\n}\n/**\n * Label heuristic selecting edge labels to display, based on displayed node\n * labels\n *\n * @param  {object} params                 - Parameters:\n * @param  {Set}      displayedNodeLabels  - Currently displayed node labels.\n * @param  {Set}      highlightedNodes     - Highlighted nodes.\n * @param  {Graph}    graph                - The rendered graph.\n * @param  {string}   hoveredNode          - Hovered node (optional)\n * @return {Array}                         - The selected labels.\n */\n\n\nfunction edgeLabelsToDisplayFromNodes(params) {\n  var graph = params.graph,\n      hoveredNode = params.hoveredNode,\n      highlightedNodes = params.highlightedNodes,\n      displayedNodeLabels = params.displayedNodeLabels;\n  var worthyEdges = new Set();\n  var displayedNodeLabelsArray = Array.from(displayedNodeLabels); // Each edge connecting a highlighted node has its label displayed:\n\n  var highlightedNodesArray = Array.from(highlightedNodes);\n  if (hoveredNode && !highlightedNodes.has(hoveredNode)) highlightedNodesArray.push(hoveredNode);\n\n  for (var i = 0; i < highlightedNodesArray.length; i++) {\n    var key = highlightedNodesArray[i];\n    var edges = graph.edges(key);\n\n    for (var j = 0; j < edges.length; j++) {\n      worthyEdges.add(edges[j]);\n    }\n  } // Each edge connecting two nodes with visible labels has its label displayed:\n\n\n  for (var _i2 = 0; _i2 < displayedNodeLabelsArray.length; _i2++) {\n    var _key2 = displayedNodeLabelsArray[_i2];\n\n    var _edges = graph.outboundEdges(_key2);\n\n    for (var _j = 0; _j < _edges.length; _j++) {\n      if (displayedNodeLabels.has(graph.opposite(_key2, _edges[_j]))) worthyEdges.add(_edges[_j]);\n    }\n  }\n\n  return Array.from(worthyEdges);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zIndexOrdering = zIndexOrdering;\n\n/**\n * Sigma.js zIndex Heuristics\n * ===========================\n *\n * Miscelleneous heuristics related to z-index ordering of nodes & edges.\n */\n\n/**\n * Function ordering the given elements in reverse z-order so they drawn\n * the correct way.\n *\n * @param  {number}   extent   - [min, max] z values.\n * @param  {function} getter   - Z attribute getter function.\n * @param  {array}    elements - The array to sort.\n * @return {array} - The sorted array.\n */\nfunction zIndexOrdering(extent, getter, elements) {\n  // const n = elements.length;\n  // const [min, max] = extent;\n  // const k = max - min;\n  // No ordering needs to be done\n  // if (k === 0 || k === -Infinity)\n  //   return elements;\n  // If k is > n, we'll use a standard sort\n  return elements.sort(function (a, b) {\n    var zA = getter(a) || 0,\n        zB = getter(b) || 0;\n    if (zA < zB) return -1;\n    if (zA > zB) return 1;\n    return 0;\n  }); // TODO: counting sort optimization\n}","/**\n * Extend function\n * ================\n *\n * Function used to push a bunch of values into an array at once.\n *\n * Its strategy is to mutate target array's length then setting the new indices\n * to be the values to add.\n *\n * A benchmark proved that it is faster than the following strategies:\n *   1) `array.push.apply(array, values)`.\n *   2) A loop of pushes.\n *   3) `array = array.concat(values)`, obviously.\n *\n * Intuitively, this is correct because when adding a lot of elements, the\n * chosen strategies does not need to handle the `arguments` object to\n * execute #.apply's variadicity and because the array know its final length\n * at the beginning, avoiding potential multiple reallocations of the underlying\n * contiguous array. Some engines may be able to optimize the loop of push\n * operations but empirically they don't seem to do so.\n */\n\n/**\n * Extends the target array with the given values.\n *\n * @param  {array} array  - Target array.\n * @param  {array} values - Values to add.\n */\nmodule.exports = function extend(array, values) {\n  var l2 = values.length;\n\n  if (l2 === 0)\n    return;\n\n  var l1 = array.length;\n\n  array.length += l2;\n\n  for (var i = 0; i < l2; i++)\n    array[l1 + i] = values[i];\n};\n","/**\n * Graphology Extent\n * ==================\n *\n * Simple function returning the extent of selected attributes of the graph.\n */\nvar isGraph = require('graphology-utils/is-graph');\n\n/**\n * Function returning the extent of the selected node attributes.\n *\n * @param  {Graph}        graph     - Target graph.\n * @param  {string|array} attribute - Single or multiple attributes.\n * @return {array|object}\n */\nfunction nodeExtent(graph, attribute) {\n  if (!isGraph(graph))\n    throw new Error('graphology-metrics/extent: the given graph is not a valid graphology instance.');\n\n  var attributes = [].concat(attribute);\n\n  var nodes = graph.nodes(),\n      node,\n      data,\n      value,\n      key,\n      a,\n      i,\n      l;\n\n  var results = {};\n\n  for (a = 0; a < attributes.length; a++) {\n    key = attributes[a];\n\n    results[key] = [Infinity, -Infinity];\n  }\n\n  for (i = 0, l = nodes.length; i < l; i++) {\n    node = nodes[i];\n    data = graph.getNodeAttributes(node);\n\n    for (a = 0; a < attributes.length; a++) {\n      key = attributes[a];\n      value = data[key];\n\n      if (value < results[key][0])\n        results[key][0] = value;\n\n      if (value > results[key][1])\n        results[key][1] = value;\n    }\n  }\n\n  return typeof attribute === 'string' ? results[attribute] : results;\n}\n\n/**\n * Function returning the extent of the selected edge attributes.\n *\n * @param  {Graph}        graph     - Target graph.\n * @param  {string|array} attribute - Single or multiple attributes.\n * @return {array|object}\n */\nfunction edgeExtent(graph, attribute) {\n  if (!isGraph(graph))\n    throw new Error('graphology-metrics/extent: the given graph is not a valid graphology instance.');\n\n  var attributes = [].concat(attribute);\n\n  var edges = graph.edges(),\n      edge,\n      data,\n      value,\n      key,\n      a,\n      i,\n      l;\n\n  var results = {};\n\n  for (a = 0; a < attributes.length; a++) {\n    key = attributes[a];\n\n    results[key] = [Infinity, -Infinity];\n  }\n\n  for (i = 0, l = edges.length; i < l; i++) {\n    edge = edges[i];\n    data = graph.getEdgeAttributes(edge);\n\n    for (a = 0; a < attributes.length; a++) {\n      key = attributes[a];\n      value = data[key];\n\n      if (value < results[key][0])\n        results[key][0] = value;\n\n      if (value > results[key][1])\n        results[key][1] = value;\n    }\n  }\n\n  return typeof attribute === 'string' ? results[attribute] : results;\n}\n\n/**\n * Exporting.\n */\nvar extent = nodeExtent;\nextent.nodeExtent = nodeExtent;\nextent.edgeExtent = edgeExtent;\n\nmodule.exports = extent;\n","/**\n * Graphology isGraph\n * ===================\n *\n * Very simple function aiming at ensuring the given variable is a\n * graphology instance.\n */\n\n/**\n * Checking the value is a graphology instance.\n *\n * @param  {any}     value - Target value.\n * @return {boolean}\n */\nmodule.exports = function isGraph(value) {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    typeof value.addUndirectedEdgeWithKey === 'function' &&\n    typeof value.dropNode === 'function' &&\n    typeof value.multi === 'boolean'\n  );\n};\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _extend = _interopRequireDefault(require(\"@yomguithereal/helpers/extend\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// TODO: should not ask the quadtree when the camera has the whole graph in\n// sight.\n// TODO: a square can be represented as topleft + width, saying for the quad blocks (reduce mem)\n// TODO: jsdoc\n// TODO: be sure we can handle cases overcoming boundaries (because of size) or use a maxed size\n// TODO: filtering unwanted labels beforehand through the filter function\n// NOTE: this is basically a MX-CIF Quadtree at this point\n// NOTE: need to explore R-Trees for edges\n// NOTE: need to explore 2d segment tree for edges\n// NOTE: probably can do faster using spatial hashing\n\n/**\n * Constants.\n *\n * Note that since we are representing a static 4-ary tree, the indices of the\n * quadrants are the following:\n *   - TOP_LEFT:     4i + b\n *   - TOP_RIGHT:    4i + 2b\n *   - BOTTOM_LEFT:  4i + 3b\n *   - BOTTOM_RIGHT: 4i + 4b\n */\nvar BLOCKS = 4,\n    MAX_LEVEL = 5;\nvar X_OFFSET = 0,\n    Y_OFFSET = 1,\n    WIDTH_OFFSET = 2,\n    HEIGHT_OFFSET = 3;\nvar TOP_LEFT = 1,\n    TOP_RIGHT = 2,\n    BOTTOM_LEFT = 3,\n    BOTTOM_RIGHT = 4;\n/**\n * Geometry helpers.\n */\n\n/**\n * Function returning whether the given rectangle is axis-aligned.\n *\n * @param  {number} x1\n * @param  {number} y1\n * @param  {number} x2\n * @param  {number} y2\n * @return {boolean}\n */\n\nfunction isAxisAligned(x1, y1, x2, y2) {\n  return x1 === x2 || y1 === y2;\n}\n\nfunction squareCollidesWithQuad(x1, y1, w, qx, qy, qw, qh) {\n  return x1 < qx + qw && x1 + w > qx && y1 < qy + qh && y1 + w > qy;\n}\n\nfunction rectangleCollidesWithQuad(x1, y1, w, h, qx, qy, qw, qh) {\n  return x1 < qx + qw && x1 + w > qx && y1 < qy + qh && y1 + h > qy;\n}\n\nfunction pointIsInQuad(x, y, qx, qy, qw, qh) {\n  var xmp = qx + qw / 2,\n      ymp = qy + qh / 2,\n      top = y < ymp,\n      left = x < xmp;\n  return top ? left ? TOP_LEFT : TOP_RIGHT : left ? BOTTOM_LEFT : BOTTOM_RIGHT;\n}\n/**\n * Helper functions that are not bound to the class so an external user\n * cannot mess with them.\n */\n\n\nfunction buildQuadrants(maxLevel, data) {\n  // [block, level]\n  var stack = [0, 0];\n\n  while (stack.length) {\n    var level = stack.pop(),\n        block = stack.pop();\n    var topLeftBlock = 4 * block + BLOCKS,\n        topRightBlock = 4 * block + 2 * BLOCKS,\n        bottomLeftBlock = 4 * block + 3 * BLOCKS,\n        bottomRightBlock = 4 * block + 4 * BLOCKS;\n    var x = data[block + X_OFFSET],\n        y = data[block + Y_OFFSET],\n        width = data[block + WIDTH_OFFSET],\n        height = data[block + HEIGHT_OFFSET],\n        hw = width / 2,\n        hh = height / 2;\n    data[topLeftBlock + X_OFFSET] = x;\n    data[topLeftBlock + Y_OFFSET] = y;\n    data[topLeftBlock + WIDTH_OFFSET] = hw;\n    data[topLeftBlock + HEIGHT_OFFSET] = hh;\n    data[topRightBlock + X_OFFSET] = x + hw;\n    data[topRightBlock + Y_OFFSET] = y;\n    data[topRightBlock + WIDTH_OFFSET] = hw;\n    data[topRightBlock + HEIGHT_OFFSET] = hh;\n    data[bottomLeftBlock + X_OFFSET] = x;\n    data[bottomLeftBlock + Y_OFFSET] = y + hh;\n    data[bottomLeftBlock + WIDTH_OFFSET] = hw;\n    data[bottomLeftBlock + HEIGHT_OFFSET] = hh;\n    data[bottomRightBlock + X_OFFSET] = x + hw;\n    data[bottomRightBlock + Y_OFFSET] = y + hh;\n    data[bottomRightBlock + WIDTH_OFFSET] = hw;\n    data[bottomRightBlock + HEIGHT_OFFSET] = hh;\n\n    if (level < maxLevel - 1) {\n      stack.push(bottomRightBlock, level + 1);\n      stack.push(bottomLeftBlock, level + 1);\n      stack.push(topRightBlock, level + 1);\n      stack.push(topLeftBlock, level + 1);\n    }\n  }\n}\n\nfunction insertNode(maxLevel, data, containers, key, x, y, size) {\n  var x1 = x - size,\n      y1 = y - size,\n      w = size * 2;\n  var level = 0,\n      block = 0;\n\n  while (true) {\n    // If we reached max level\n    if (level >= maxLevel) {\n      containers[block] = containers[block] || [];\n      containers[block].push(key);\n      return;\n    }\n\n    var topLeftBlock = 4 * block + BLOCKS,\n        topRightBlock = 4 * block + 2 * BLOCKS,\n        bottomLeftBlock = 4 * block + 3 * BLOCKS,\n        bottomRightBlock = 4 * block + 4 * BLOCKS;\n    var collidingWithTopLeft = squareCollidesWithQuad(x1, y1, w, data[topLeftBlock + X_OFFSET], data[topLeftBlock + Y_OFFSET], data[topLeftBlock + WIDTH_OFFSET], data[topLeftBlock + HEIGHT_OFFSET]);\n    var collidingWithTopRight = squareCollidesWithQuad(x1, y1, w, data[topRightBlock + X_OFFSET], data[topRightBlock + Y_OFFSET], data[topRightBlock + WIDTH_OFFSET], data[topRightBlock + HEIGHT_OFFSET]);\n    var collidingWithBottomLeft = squareCollidesWithQuad(x1, y1, w, data[bottomLeftBlock + X_OFFSET], data[bottomLeftBlock + Y_OFFSET], data[bottomLeftBlock + WIDTH_OFFSET], data[bottomLeftBlock + HEIGHT_OFFSET]);\n    var collidingWithBottomRight = squareCollidesWithQuad(x1, y1, w, data[bottomRightBlock + X_OFFSET], data[bottomRightBlock + Y_OFFSET], data[bottomRightBlock + WIDTH_OFFSET], data[bottomRightBlock + HEIGHT_OFFSET]);\n    var collisions = collidingWithTopLeft + collidingWithTopRight + collidingWithBottomLeft + collidingWithBottomRight; // If we don't have at least a collision, there is an issue\n\n    if (collisions === 0) throw new Error(\"sigma/quadtree.insertNode: no collision (level: \".concat(level, \", key: \").concat(key, \", x: \").concat(x, \", y: \").concat(y, \", size: \").concat(size, \").\")); // If we have 3 collisions, we have a geometry problem obviously\n\n    if (collisions === 3) throw new Error(\"sigma/quadtree.insertNode: 3 impossible collisions (level: \".concat(level, \", key: \").concat(key, \", x: \").concat(x, \", y: \").concat(y, \", size: \").concat(size, \").\")); // If we have more that one collision, we stop here and store the node\n    // in the relevant containers\n\n    if (collisions > 1) {\n      // NOTE: this is a nice way to optimize for hover, but not for frustum\n      // since it requires to uniq the collected nodes\n      // if (collisions < 4) {\n      //   // If we intersect two quads, we place the node in those two\n      //   if (collidingWithTopLeft) {\n      //     containers[topLeftBlock] = containers[topLeftBlock] || [];\n      //     containers[topLeftBlock].push(key);\n      //   }\n      //   if (collidingWithTopRight) {\n      //     containers[topRightBlock] = containers[topRightBlock] || [];\n      //     containers[topRightBlock].push(key);\n      //   }\n      //   if (collidingWithBottomLeft) {\n      //     containers[bottomLeftBlock] = containers[bottomLeftBlock] || [];\n      //     containers[bottomLeftBlock].push(key);\n      //   }\n      //   if (collidingWithBottomRight) {\n      //     containers[bottomRightBlock] = containers[bottomRightBlock] || [];\n      //     containers[bottomRightBlock].push(key);\n      //   }\n      // }\n      // else {\n      //   // Else we keep the node where it is to avoid more pointless computations\n      //   containers[block] = containers[block] || [];\n      //   containers[block].push(key);\n      // }\n      containers[block] = containers[block] || [];\n      containers[block].push(key);\n      return;\n    } else {\n      level++;\n    } // Else we recurse into the correct quads\n\n\n    if (collidingWithTopLeft) block = topLeftBlock;\n    if (collidingWithTopRight) block = topRightBlock;\n    if (collidingWithBottomLeft) block = bottomLeftBlock;\n    if (collidingWithBottomRight) block = bottomRightBlock;\n  }\n}\n\nfunction getNodesInAxisAlignedRectangleArea(maxLevel, data, containers, x1, y1, w, h) {\n  // [block, level]\n  var stack = [0, 0];\n  var collectedNodes = [];\n  var container;\n\n  while (stack.length) {\n    var level = stack.pop(),\n        block = stack.pop(); // Collecting nodes\n\n    container = containers[block];\n    if (container) (0, _extend[\"default\"])(collectedNodes, container); // If we reached max level\n\n    if (level >= maxLevel) continue;\n    var topLeftBlock = 4 * block + BLOCKS,\n        topRightBlock = 4 * block + 2 * BLOCKS,\n        bottomLeftBlock = 4 * block + 3 * BLOCKS,\n        bottomRightBlock = 4 * block + 4 * BLOCKS;\n    var collidingWithTopLeft = rectangleCollidesWithQuad(x1, y1, w, h, data[topLeftBlock + X_OFFSET], data[topLeftBlock + Y_OFFSET], data[topLeftBlock + WIDTH_OFFSET], data[topLeftBlock + HEIGHT_OFFSET]);\n    var collidingWithTopRight = rectangleCollidesWithQuad(x1, y1, w, h, data[topRightBlock + X_OFFSET], data[topRightBlock + Y_OFFSET], data[topRightBlock + WIDTH_OFFSET], data[topRightBlock + HEIGHT_OFFSET]);\n    var collidingWithBottomLeft = rectangleCollidesWithQuad(x1, y1, w, h, data[bottomLeftBlock + X_OFFSET], data[bottomLeftBlock + Y_OFFSET], data[bottomLeftBlock + WIDTH_OFFSET], data[bottomLeftBlock + HEIGHT_OFFSET]);\n    var collidingWithBottomRight = rectangleCollidesWithQuad(x1, y1, w, h, data[bottomRightBlock + X_OFFSET], data[bottomRightBlock + Y_OFFSET], data[bottomRightBlock + WIDTH_OFFSET], data[bottomRightBlock + HEIGHT_OFFSET]);\n    if (collidingWithTopLeft) stack.push(topLeftBlock, level + 1);\n    if (collidingWithTopRight) stack.push(topRightBlock, level + 1);\n    if (collidingWithBottomLeft) stack.push(bottomLeftBlock, level + 1);\n    if (collidingWithBottomRight) stack.push(bottomRightBlock, level + 1);\n  }\n\n  return collectedNodes;\n}\n/**\n * QuadTree class.\n *\n * @constructor\n * @param {object} boundaries - The graph boundaries.\n */\n\n\nvar QuadTree =\n/*#__PURE__*/\nfunction () {\n  function QuadTree(params) {\n    _classCallCheck(this, QuadTree);\n\n    params = params || {}; // Allocating the underlying byte array\n\n    var L = Math.pow(4, MAX_LEVEL);\n    this.data = new Float32Array(BLOCKS * ((4 * L - 1) / 3));\n    this.containers = {};\n    this.cache = null;\n    this.lastRectangle = null;\n    if (params.boundaries) this.resize(params.boundaries);else this.resize({\n      x: 0,\n      y: 0,\n      width: 1,\n      height: 1\n    });\n    if (typeof params.filter === 'function') this.nodeFilter = params.filter;\n  }\n\n  _createClass(QuadTree, [{\n    key: \"add\",\n    value: function add(key, x, y, size) {\n      insertNode(MAX_LEVEL, this.data, this.containers, key, x, y, size);\n      return this;\n    }\n  }, {\n    key: \"resize\",\n    value: function resize(boundaries) {\n      this.clear(); // Building the quadrants\n\n      this.data[X_OFFSET] = boundaries.x;\n      this.data[Y_OFFSET] = boundaries.y;\n      this.data[WIDTH_OFFSET] = boundaries.width;\n      this.data[HEIGHT_OFFSET] = boundaries.height;\n      buildQuadrants(MAX_LEVEL, this.data);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.containers = {};\n      return this;\n    }\n  }, {\n    key: \"point\",\n    value: function point(x, y) {\n      var nodes = [];\n      var block = 0,\n          level = 0;\n\n      do {\n        if (this.containers[block]) nodes.push.apply(nodes, this.containers[block]);\n        var quad = pointIsInQuad(x, y, this.data[block + X_OFFSET], this.data[block + Y_OFFSET], this.data[block + WIDTH_OFFSET], this.data[block + HEIGHT_OFFSET]);\n        block = 4 * block + quad * BLOCKS;\n        level++;\n      } while (level <= MAX_LEVEL);\n\n      return nodes;\n    }\n  }, {\n    key: \"rectangle\",\n    value: function rectangle(x1, y1, x2, y2, height) {\n      var lr = this.lastRectangle;\n\n      if (lr && x1 === lr.x1 && x2 === lr.x2 && y1 === lr.y1 && y2 === lr.y2 && height === lr.height) {\n        return this.cache;\n      }\n\n      this.lastRectangle = {\n        x1: x1,\n        y1: y1,\n        x2: x2,\n        y2: y2,\n        height: height\n      }; // Is the rectangle axis aligned?\n\n      if (!isAxisAligned(x1, y1, x2, y2)) throw new Error('sigma/quadtree.rectangle: shifted view is not yet implemented.');\n      var collectedNodes = getNodesInAxisAlignedRectangleArea(MAX_LEVEL, this.data, this.containers, x1, y1, Math.abs(x1 - x2) || Math.abs(y1 - y2), height);\n      this.cache = collectedNodes;\n      return this.cache;\n    }\n  }]);\n\n  return QuadTree;\n}();\n\nexports[\"default\"] = QuadTree;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _events = require(\"events\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * Renderer class.\n *\n * @constructor\n */\nvar Renderer =\n/*#__PURE__*/\nfunction (_EventEmitter) {\n  _inherits(Renderer, _EventEmitter);\n\n  function Renderer() {\n    _classCallCheck(this, Renderer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Renderer).apply(this, arguments));\n  }\n\n  return Renderer;\n}(_events.EventEmitter);\n\nexports[\"default\"] = Renderer;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = drawEdgeLabel;\n\n/**\n * Sigma.js Canvas Renderer Edge Label Component\n * =============================================\n *\n * Function used by the canvas renderer to display a single edge's label.\n */\nfunction drawEdgeLabel(context, edgeData, sourceData, targetData, settings) {\n  var size = settings.edgeLabelSize,\n      font = settings.edgeLabelFont,\n      weight = settings.edgeLabelWeight,\n      label = edgeData.label;\n  context.fillStyle = edgeData.color;\n  context.font = \"\".concat(weight, \" \").concat(size, \"px \").concat(font);\n  var textWidth = context.measureText(label).width;\n  var cx = (sourceData.x + targetData.x) / 2;\n  var cy = (sourceData.y + targetData.y) / 2;\n  var dx = targetData.x - sourceData.x;\n  var dy = targetData.y - sourceData.y;\n  var d = Math.sqrt(dx * dx + dy * dy);\n  var angle;\n\n  if (dx > 0) {\n    if (dy > 0) angle = Math.acos(dx / d);else angle = Math.asin(dy / d);\n  } else {\n    if (dy > 0) angle = Math.acos(dx / d) + Math.PI;else angle = Math.asin(dx / d) + Math.PI / 2;\n  }\n\n  context.save();\n  context.translate(cx, cy);\n  context.rotate(angle);\n  context.fillText(label, -textWidth / 2, edgeData.size / 2 + size);\n  context.restore();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = drawHover;\n\nvar _node = _interopRequireDefault(require(\"./node\"));\n\nvar _label = _interopRequireDefault(require(\"./label\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/**\n * Sigma.js Canvas Renderer Hover Component\n * =========================================\n *\n * Function used by the canvas renderer to display a single node's hovered\n * state.\n */\nfunction drawHover(context, data, settings) {\n  var size = settings.labelSize,\n      font = settings.labelFont,\n      weight = settings.labelWeight;\n  context.font = \"\".concat(weight, \" \").concat(size, \"px \").concat(font); // Then we draw the label background\n\n  context.beginPath();\n  context.fillStyle = '#fff';\n  context.shadowOffsetX = 0;\n  context.shadowOffsetY = 0;\n  context.shadowBlur = 8;\n  context.shadowColor = '#000';\n  var textWidth = context.measureText(data.label).width;\n  var x = Math.round(data.x - size / 2 - 2),\n      y = Math.round(data.y - size / 2 - 2),\n      w = Math.round(textWidth + size / 2 + data.size + 9),\n      h = Math.round(size + 4),\n      e = Math.round(size / 2 + 2);\n  context.moveTo(x, y + e);\n  context.moveTo(x, y + e);\n  context.arcTo(x, y, x + e, y, e);\n  context.lineTo(x + w, y);\n  context.lineTo(x + w, y + h);\n  context.lineTo(x + e, y + h);\n  context.arcTo(x, y + h, x, y + h - e, e);\n  context.lineTo(x, y + e);\n  context.closePath();\n  context.fill();\n  context.shadowOffsetX = 0;\n  context.shadowOffsetY = 0;\n  context.shadowBlur = 0; // Then we need to draw the node\n\n  (0, _node[\"default\"])(context, data); // And finally we draw the label\n\n  (0, _label[\"default\"])(context, data, settings);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = drawLabel;\n\n/**\n * Sigma.js Canvas Renderer Label Component\n * =========================================\n *\n * Function used by the canvas renderer to display a single node's label.\n */\nfunction drawLabel(context, data, settings) {\n  var size = settings.labelSize,\n      font = settings.labelFont,\n      weight = settings.labelWeight;\n  context.fillStyle = '#000';\n  context.font = \"\".concat(weight, \" \").concat(size, \"px \").concat(font);\n  context.fillText(data.label, data.x + data.size + 3, data.y + size / 3);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = drawNode;\n\n/**\n * Sigma.js Canvas Renderer Node Component\n * ========================================\n *\n * Function used by the canvas renderer to display a single node.\n */\nvar PI_TIMES_2 = Math.PI * 2;\n\nfunction drawNode(context, data) {\n  context.fillStyle = data.color;\n  context.beginPath();\n  context.arc(data.x, data.y, data.size, 0, PI_TIMES_2, true);\n  context.closePath();\n  context.fill();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EdgeDisplayData = exports.NodeDisplayData = void 0;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * Sigma.js Display Data Classes\n * ==============================\n *\n * Classes representing nodes & edges display data aiming at facilitating\n * the engine's memory representation and keep them in a pool to avoid\n * requiring to allocate memory too often.\n *\n * NOTE: it's possible to optimize this further by maintaining display data\n * in byte arrays but this would prove more tedious for the rendering logic\n * afterwards.\n */\nvar NodeDisplayData =\n/*#__PURE__*/\nfunction () {\n  function NodeDisplayData(index, settings) {\n    _classCallCheck(this, NodeDisplayData);\n\n    this.index = index;\n    this.x = 0;\n    this.y = 0;\n    this.size = 2;\n    this.color = settings.defaultNodeColor;\n    this.hidden = false;\n    this.label = '';\n  }\n\n  _createClass(NodeDisplayData, [{\n    key: \"assign\",\n    value: function assign(data) {\n      for (var key in data) {\n        this[key] = data[key];\n      }\n    }\n  }]);\n\n  return NodeDisplayData;\n}();\n\nexports.NodeDisplayData = NodeDisplayData;\n\nvar EdgeDisplayData =\n/*#__PURE__*/\nfunction () {\n  function EdgeDisplayData(index, settings) {\n    _classCallCheck(this, EdgeDisplayData);\n\n    this.index = index;\n    this.size = 1;\n    this.color = settings.defaultEdgeColor;\n    this.hidden = false;\n    this.label = '';\n  }\n\n  _createClass(EdgeDisplayData, [{\n    key: \"assign\",\n    value: function assign(data) {\n      for (var key in data) {\n        this[key] = data[key];\n      }\n    }\n  }]);\n\n  return EdgeDisplayData;\n}();\n\nexports.EdgeDisplayData = EdgeDisplayData;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createElement = createElement;\nexports.getPixelRatio = getPixelRatio;\nexports.createNormalizationFunction = createNormalizationFunction;\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/**\n * Sigma.js Rendering Utils\n * ===========================\n *\n * Helpers used by most renderers.\n */\n\n/**\n * Function used to create DOM elements easily.\n *\n * @param  {string} tag        - Tag name of the element to create.\n * @param  {object} attributes - Attributes map.\n * @return {HTMLElement}\n */\nfunction createElement(tag, attributes) {\n  var element = document.createElement(tag);\n  if (!attributes) return element;\n\n  for (var k in attributes) {\n    if (k === 'style') {\n      for (var s in attributes[k]) {\n        element.style[s] = attributes[k][s];\n      }\n    } else {\n      element.setAttribute(k, attributes[k]);\n    }\n  }\n\n  return element;\n}\n/**\n * Function returning the browser's pixel ratio.\n *\n * @return {number}\n */\n\n\nfunction getPixelRatio() {\n  var screen = window.screen;\n  if (typeof screen.deviceXDPI !== 'undefined' && typeof screen.logicalXDPI !== 'undefined' && screen.deviceXDPI > screen.logicalXDPI) return screen.systemXDPI / screen.logicalXDPI;else if (typeof window.devicePixelRatio !== 'undefined') return window.devicePixelRatio;\n  return 1;\n}\n/**\n * Factory returning a function normalizing the given node's position & size.\n *\n * @param  {object}   extent  - Extent of the graph.\n * @return {function}\n */\n\n\nfunction createNormalizationFunction(extent) {\n  var _extent$x = _slicedToArray(extent.x, 2),\n      minX = _extent$x[0],\n      maxX = _extent$x[1],\n      _extent$y = _slicedToArray(extent.y, 2),\n      minY = _extent$y[0],\n      maxY = _extent$y[1];\n\n  var ratio = Math.max(maxX - minX, maxY - minY);\n  if (ratio === 0) ratio = 1;\n  var dX = (maxX + minX) / 2,\n      dY = (maxY + minY) / 2;\n\n  var fn = function fn(data) {\n    return {\n      x: 0.5 + (data.x - dX) / ratio,\n      y: 0.5 + (data.y - dY) / ratio\n    };\n  }; // TODO: possibility to apply this in batch over array of indices\n\n\n  fn.applyTo = function (data) {\n    data.x = 0.5 + (data.x - dX) / ratio;\n    data.y = 0.5 + (data.y - dY) / ratio;\n  };\n\n  fn.inverse = function (data) {\n    return {\n      x: dX + ratio * (data.x - 0.5),\n      y: dY + ratio * (data.y - 0.5)\n    };\n  };\n\n  fn.ratio = ratio;\n  return fn;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _extent = require(\"graphology-metrics/extent\");\n\nvar _isGraph = _interopRequireDefault(require(\"graphology-utils/is-graph\"));\n\nvar _renderer = _interopRequireDefault(require(\"../../renderer\"));\n\nvar _camera = _interopRequireDefault(require(\"../../camera\"));\n\nvar _mouse = _interopRequireDefault(require(\"../../captors/mouse\"));\n\nvar _quadtree = _interopRequireDefault(require(\"../../quadtree\"));\n\nvar _displayData2 = require(\"../display-data\");\n\nvar _utils = require(\"../../utils\");\n\nvar _utils2 = require(\"../utils\");\n\nvar _utils3 = require(\"./utils\");\n\nvar _labels = require(\"../../heuristics/labels\");\n\nvar _zIndex = require(\"../../heuristics/z-index\");\n\nvar _settings = require(\"./settings\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n/**\n * Constants.\n */\nvar PIXEL_RATIO = (0, _utils2.getPixelRatio)();\nvar WEBGL_OVERSAMPLING_RATIO = (0, _utils2.getPixelRatio)();\n/**\n * Main class.\n *\n * @constructor\n * @param {Graph}       graph     - Graph to render.\n * @param {HTMLElement} container - DOM container in which to render.\n * @param {object}      settings  - Optional settings.\n */\n\nvar WebGLRenderer =\n/*#__PURE__*/\nfunction (_Renderer) {\n  _inherits(WebGLRenderer, _Renderer);\n\n  function WebGLRenderer(graph, container, settings) {\n    var _this;\n\n    _classCallCheck(this, WebGLRenderer);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(WebGLRenderer).call(this));\n    settings = settings || {};\n    _this.settings = (0, _utils.assign)({}, _settings.WEBGL_RENDERER_DEFAULT_SETTINGS, settings);\n    (0, _settings.validateWebglRendererSettings)(_this.settings); // Validating\n\n    if (!(0, _isGraph[\"default\"])(graph)) throw new Error('sigma/renderers/webgl: invalid graph instance.');\n    if (!(container instanceof HTMLElement)) throw new Error('sigma/renderers/webgl: container should be an html element.'); // Properties\n\n    _this.graph = graph;\n    _this.captors = {};\n    _this.container = container;\n    _this.elements = {};\n    _this.contexts = {};\n    _this.listeners = {}; // Indices & cache\n    // TODO: this could be improved by key => index => floatArray\n    // TODO: the cache should erase keys on node delete & add new\n\n    _this.quadtree = new _quadtree[\"default\"]();\n    _this.nodeDataCache = {};\n    _this.edgeDataCache = {};\n    _this.nodeExtent = null;\n    _this.edgeExtent = null;\n\n    _this.initializeCache(); // Normalization function\n\n\n    _this.normalizationFunction = null; // Starting dimensions\n\n    _this.width = 0;\n    _this.height = 0; // State\n\n    _this.highlightedNodes = new Set();\n    _this.displayedLabels = new Set();\n    _this.hoveredNode = null;\n    _this.wasRenderedInThisFrame = false;\n    _this.renderFrame = null;\n    _this.renderHighlightedNodesFrame = null;\n    _this.needToProcess = false;\n    _this.needToSoftProcess = false; // Initializing contexts\n\n    _this.createContext('edges');\n\n    _this.createContext('edgeLabels', false);\n\n    _this.createContext('nodes');\n\n    _this.createContext('labels', false);\n\n    _this.createContext('hovers', false);\n\n    _this.createContext('mouse', false); // Blending\n\n\n    var gl = _this.contexts.nodes;\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    gl.enable(gl.BLEND);\n    gl = _this.contexts.edges;\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    gl.enable(gl.BLEND); // Loading programs\n\n    _this.nodePrograms = {};\n    _this.edgePrograms = {};\n\n    for (var type in _this.settings.nodeProgramClasses) {\n      var NodeProgramClass = _this.settings.nodeProgramClasses[type];\n      _this.nodePrograms[type] = new NodeProgramClass(_this.contexts.nodes);\n    }\n\n    for (var _type in _this.settings.edgeProgramClasses) {\n      var EdgeProgramClass = _this.settings.edgeProgramClasses[_type];\n      _this.edgePrograms[_type] = new EdgeProgramClass(_this.contexts.edges);\n    } // Initial resize\n\n\n    _this.resize(); // Initializing the camera\n\n\n    _this.camera = new _camera[\"default\"]({\n      width: _this.width,\n      height: _this.height\n    }); // Binding camera events\n\n    _this.bindCameraHandlers(); // Initializing captors\n\n\n    _this.captors = {\n      mouse: new _mouse[\"default\"](_this.elements.mouse, _this.camera)\n    }; // Binding event handlers\n\n    _this.bindEventHandlers(); // Binding graph handlers\n\n\n    _this.bindGraphHandlers(); // Processing data for the first time & render\n\n\n    _this.process();\n\n    _this.render();\n\n    return _this;\n  }\n  /**---------------------------------------------------------------------------\n   * Internal methods.\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Internal function used to create a canvas context and add the relevant\n   * DOM elements.\n   *\n   * @param  {string}  id    - Context's id.\n   * @param  {boolean} webgl - Whether the context is a webgl or canvas one.\n   * @return {WebGLRenderer}\n   */\n\n\n  _createClass(WebGLRenderer, [{\n    key: \"createContext\",\n    value: function createContext(id) {\n      var webgl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var element = (0, _utils2.createElement)('canvas', {\n        \"class\": \"sigma-\".concat(id),\n        style: {\n          position: 'absolute'\n        }\n      });\n      this.elements[id] = element;\n      this.container.appendChild(element);\n      var contextOptions = {\n        preserveDrawingBuffer: false,\n        antialias: false\n      };\n      var context;\n\n      if (webgl) {\n        // First we try webgl2 for an easy performance boost\n        context = element.getContext('webgl2', contextOptions); // Else we fall back to webgl\n\n        if (!context) context = element.getContext('webgl', contextOptions); // Edge, I am looking right at you...\n\n        if (!context) context = element.getContext('experimental-webgl', contextOptions);\n      } else {\n        context = element.getContext('2d', contextOptions);\n      }\n\n      this.contexts[id] = context;\n      return this;\n    }\n    /**\n     * Method used to initialize display data cache.\n     *\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"initializeCache\",\n    value: function initializeCache() {\n      var graph = this.graph;\n      var nodes = graph.nodes();\n\n      for (var i = 0, l = nodes.length; i < l; i++) {\n        this.nodeDataCache[nodes[i]] = new _displayData2.NodeDisplayData(i, this.settings);\n      }\n\n      var edges = graph.edges();\n\n      for (var _i = 0, _l = edges.length; _i < _l; _i++) {\n        this.edgeDataCache[edges[_i]] = new _displayData2.EdgeDisplayData(_i, this.settings);\n      }\n    }\n    /**\n     * Method binding camera handlers.\n     *\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"bindCameraHandlers\",\n    value: function bindCameraHandlers() {\n      var _this2 = this;\n\n      this.listeners.camera = function () {\n        _this2.scheduleRender();\n      };\n\n      this.camera.on('updated', this.listeners.camera);\n      return this;\n    }\n    /**\n     * Method binding event handlers.\n     *\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"bindEventHandlers\",\n    value: function bindEventHandlers() {\n      var _this3 = this;\n\n      // Handling window resize\n      this.listeners.handleResize = function () {\n        _this3.needToSoftProcess = true;\n\n        _this3.scheduleRender();\n      };\n\n      window.addEventListener('resize', this.listeners.handleResize); // Function checking if the mouse is on the given node\n\n      var mouseIsOnNode = function mouseIsOnNode(mouseX, mouseY, nodeX, nodeY, size) {\n        return mouseX > nodeX - size && mouseX < nodeX + size && mouseY > nodeY - size && mouseY < nodeY + size && Math.sqrt(Math.pow(mouseX - nodeX, 2) + Math.pow(mouseY - nodeY, 2)) < size;\n      }; // Function returning the nodes in the mouse's quad\n\n\n      var getQuadNodes = function getQuadNodes(mouseX, mouseY) {\n        var mouseGraphPosition = _this3.camera.viewportToGraph(_this3, mouseX, mouseY); // TODO: minus 1? lol\n\n\n        return _this3.quadtree.point(mouseGraphPosition.x, 1 - mouseGraphPosition.y);\n      }; // Handling mouse move\n\n\n      this.listeners.handleMove = function (e) {\n        // NOTE: for the canvas renderer, testing the pixel's alpha should\n        // give some boost but this slows things down for WebGL empirically.\n        // TODO: this should be a method from the camera (or can be passed to graph to display somehow)\n        var sizeRatio = Math.pow(_this3.camera.getState().ratio, 0.5);\n        var quadNodes = getQuadNodes(e.x, e.y); // We will hover the node whose center is closest to mouse\n\n        var minDistance = Infinity,\n            nodeToHover = null;\n\n        for (var i = 0, l = quadNodes.length; i < l; i++) {\n          var node = quadNodes[i];\n          var data = _this3.nodeDataCache[node];\n\n          var pos = _this3.camera.graphToViewport(_this3, data.x, data.y);\n\n          var size = data.size / sizeRatio;\n\n          if (mouseIsOnNode(e.x, e.y, pos.x, pos.y, size)) {\n            var distance = Math.sqrt(Math.pow(e.x - pos.x, 2) + Math.pow(e.y - pos.y, 2)); // TODO: sort by min size also for cases where center is the same\n\n            if (distance < minDistance) {\n              minDistance = distance;\n              nodeToHover = node;\n            }\n          }\n        }\n\n        if (nodeToHover && _this3.hoveredNode !== nodeToHover) {\n          // Handling passing from one node to the other directly\n          if (_this3.hoveredNode !== null) _this3.emit('leaveNode', {\n            node: _this3.hoveredNode\n          });\n          _this3.hoveredNode = nodeToHover;\n\n          _this3.emit('enterNode', {\n            node: nodeToHover\n          });\n\n          return _this3.scheduleHighlightedNodesRender();\n        } // Checking if the hovered node is still hovered\n\n\n        if (_this3.hoveredNode) {\n          var _data = _this3.nodeDataCache[_this3.hoveredNode];\n\n          var _pos = _this3.camera.graphToViewport(_this3, _data.x, _data.y);\n\n          var _size = _data.size / sizeRatio;\n\n          if (!mouseIsOnNode(e.x, e.y, _pos.x, _pos.y, _size)) {\n            var _node = _this3.hoveredNode;\n            _this3.hoveredNode = null;\n\n            _this3.emit('leaveNode', {\n              node: _node\n            });\n\n            return _this3.scheduleHighlightedNodesRender();\n          }\n        }\n      }; // Handling click\n\n\n      this.listeners.handleClick = function (e) {\n        var sizeRatio = Math.pow(_this3.camera.getState().ratio, 0.5);\n        var quadNodes = getQuadNodes(e.x, e.y);\n\n        for (var i = 0, l = quadNodes.length; i < l; i++) {\n          var node = quadNodes[i];\n          var data = _this3.nodeDataCache[node];\n\n          var pos = _this3.camera.graphToViewport(_this3, data.x, data.y);\n\n          var size = data.size / sizeRatio;\n          if (mouseIsOnNode(e.x, e.y, pos.x, pos.y, size)) return _this3.emit('clickNode', {\n            node: node,\n            captor: e\n          });\n        }\n\n        return _this3.emit('clickStage');\n      };\n\n      this.captors.mouse.on('mousemove', this.listeners.handleMove);\n      this.captors.mouse.on('click', this.listeners.handleClick);\n      return this;\n    }\n    /**\n     * Method binding graph handlers\n     *\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"bindGraphHandlers\",\n    value: function bindGraphHandlers() {\n      var _this4 = this;\n\n      var graph = this.graph;\n\n      this.listeners.graphUpdate = function () {\n        _this4.needToProcess = true;\n\n        _this4.scheduleRender();\n      };\n\n      this.listeners.softGraphUpdate = function () {\n        _this4.needToSoftProcess = true;\n\n        _this4.scheduleRender();\n      };\n\n      this.listeners.addNodeGraphUpdate = function (e) {\n        // Adding entry to cache\n        _this4.nodeDataCache[e.key] = new _displayData2.NodeDisplayData(graph.order - 1, _this4.settings);\n\n        _this4.listeners.graphUpdate();\n      };\n\n      this.listeners.addEdgeGraphUpdate = function (e) {\n        // Adding entry to cache\n        _this4.edgeDataCache[e.key] = new _displayData2.EdgeDisplayData(graph.size - 1, _this4.settings);\n\n        _this4.listeners.graphUpdate();\n      }; // TODO: clean cache on drop!\n      // TODO: bind this on composed state events\n      // TODO: it could be possible to update only specific node etc. by holding\n      // a fixed-size pool of updated items\n\n\n      graph.on('nodeAdded', this.listeners.addNodeGraphUpdate);\n      graph.on('nodeDropped', this.listeners.graphUpdate);\n      graph.on('nodeAttributesUpdated', this.listeners.softGraphUpdate);\n      graph.on('edgeAdded', this.listeners.addEdgeGraphUpdate);\n      graph.on('nodeDropped', this.listeners.graphUpdate);\n      graph.on('edgeAttributesUpdated', this.listeners.softGraphUpdate);\n      graph.on('cleared', this.listeners.graphUpdate);\n      return this;\n    }\n    /**\n     * Method used to process the whole graph's data.\n     *\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"process\",\n    value: function process() {\n      var keepArrays = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var graph = this.graph,\n          settings = this.settings; // Clearing the quad\n\n      this.quadtree.clear(); // Computing extents\n\n      var nodeExtentProperties = ['x', 'y'];\n\n      if (this.settings.zIndex) {\n        nodeExtentProperties.push('z');\n        this.edgeExtent = (0, _extent.edgeExtent)(graph, ['z']);\n      }\n\n      this.nodeExtent = (0, _extent.nodeExtent)(graph, nodeExtentProperties); // Rescaling function\n\n      this.normalizationFunction = (0, _utils2.createNormalizationFunction)(this.nodeExtent);\n      var nodeProgram = this.nodePrograms[this.settings.defaultNodeType];\n      if (!keepArrays) nodeProgram.allocate(graph.order);\n      var nodes = graph.nodes(); // Handling node z-index\n      // TODO: z-index needs us to compute display data before hand\n      // TODO: remains to be seen if reducers are a good or bad thing and if we\n      // should store display data in flat byte arrays indices\n\n      if (this.settings.zIndex) nodes = (0, _zIndex.zIndexOrdering)(this.edgeExtent.z, function (node) {\n        return graph.getNodeAttribute(node, 'z');\n      }, nodes);\n\n      for (var i = 0, l = nodes.length; i < l; i++) {\n        var node = nodes[i];\n        var data = graph.getNodeAttributes(node);\n        var displayData = this.nodeDataCache[node];\n        if (settings.nodeReducer) data = settings.nodeReducer(node, data); // TODO: should assign default also somewhere here if there is a reducer\n\n        displayData.assign(data);\n        this.normalizationFunction.applyTo(displayData);\n        this.quadtree.add(node, displayData.x, 1 - displayData.y, displayData.size / this.width);\n        nodeProgram.process(displayData, i);\n        displayData.index = i;\n      }\n\n      nodeProgram.bufferData();\n      var edgeProgram = this.edgePrograms[this.settings.defaultEdgeType];\n      if (!keepArrays) edgeProgram.allocate(graph.size);\n      var edges = graph.edges(); // Handling edge z-index\n\n      if (this.settings.zIndex) edges = (0, _zIndex.zIndexOrdering)(this.edgeExtent.z, function (edge) {\n        return graph.getEdgeAttribute(edge, 'z');\n      }, edges);\n\n      for (var _i2 = 0, _l2 = edges.length; _i2 < _l2; _i2++) {\n        var edge = edges[_i2];\n\n        var _data2 = graph.getEdgeAttributes(edge);\n\n        var _displayData = this.edgeDataCache[edge];\n        if (settings.edgeReducer) _data2 = settings.edgeReducer(edge, _data2);\n\n        _displayData.assign(_data2);\n\n        var extremities = graph.extremities(edge),\n            sourceData = this.nodeDataCache[extremities[0]],\n            targetData = this.nodeDataCache[extremities[1]];\n        edgeProgram.process(sourceData, targetData, _displayData, _i2);\n        _displayData.index = _i2;\n      } // Computing edge indices if necessary\n\n\n      if (!keepArrays && typeof edgeProgram.computeIndices === 'function') edgeProgram.computeIndices();\n      edgeProgram.bufferData();\n      return this;\n    }\n    /**\n     * Method used to process a single node.\n     *\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"processNode\",\n    value: function processNode(key) {\n      var nodeProgram = this.nodePrograms[this.settings.defaultNodeType];\n      var data = this.graph.getNodeAttributes(key);\n      nodeProgram.process(data, this.nodeDataCache[key].index);\n      return this;\n    }\n    /**\n     * Method used to process a single edge.\n     *\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"processEdge\",\n    value: function processEdge(key) {\n      var graph = this.graph;\n      var edgeProgram = this.edgePrograms[this.settings.defaultEdgeType];\n      var data = graph.getEdgeAttributes(key),\n          extremities = graph.extremities(key),\n          sourceData = graph.getNodeAttributes(extremities[0]),\n          targetData = graph.getNodeAttributes(extremities[1]);\n      edgeProgram.process(sourceData, targetData, data, this.edgeDataCache[key].index);\n      return this;\n    }\n    /**---------------------------------------------------------------------------\n     * Public API.\n     **---------------------------------------------------------------------------\n     */\n\n    /**\n     * Method returning the renderer's camera.\n     *\n     * @return {Camera}\n     */\n\n  }, {\n    key: \"getCamera\",\n    value: function getCamera() {\n      return this.camera;\n    }\n    /**\n     * Method returning the mouse captor.\n     *\n     * @return {Camera}\n     */\n\n  }, {\n    key: \"getMouseCaptor\",\n    value: function getMouseCaptor() {\n      return this.captors.mouse;\n    }\n    /**\n     * Method used to resize the renderer.\n     *\n     * @param  {number} width  - Target width.\n     * @param  {number} height - Target height.\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"resize\",\n    value: function resize(width, height) {\n      var previousWidth = this.width,\n          previousHeight = this.height;\n\n      if (arguments.length > 1) {\n        this.width = width;\n        this.height = height;\n      } else {\n        this.width = this.container.offsetWidth;\n        this.height = this.container.offsetHeight;\n      }\n\n      if (this.width === 0) throw new Error('sigma/renderers/webgl: container has no width.');\n      if (this.height === 0) throw new Error('sigma/renderers/webgl: container has no height.'); // If nothing has changed, we can stop right here\n\n      if (previousWidth === this.width && previousHeight === this.height) return this; // Sizing dom elements\n\n      for (var id in this.elements) {\n        var element = this.elements[id];\n        element.style.width = this.width + 'px';\n        element.style.height = this.height + 'px';\n      } // Sizing contexts\n\n\n      for (var _id in this.contexts) {\n        var context = this.contexts[_id]; // Canvas contexts\n\n        if (context.scale) {\n          this.elements[_id].setAttribute('width', this.width * PIXEL_RATIO + 'px');\n\n          this.elements[_id].setAttribute('height', this.height * PIXEL_RATIO + 'px');\n\n          if (PIXEL_RATIO !== 1) context.scale(PIXEL_RATIO, PIXEL_RATIO);\n        } // WebGL contexts\n        else {\n            this.elements[_id].setAttribute('width', this.width * WEBGL_OVERSAMPLING_RATIO + 'px');\n\n            this.elements[_id].setAttribute('height', this.height * WEBGL_OVERSAMPLING_RATIO + 'px');\n          }\n\n        if (context.viewport) {\n          context.viewport(0, 0, this.width * WEBGL_OVERSAMPLING_RATIO, this.height * WEBGL_OVERSAMPLING_RATIO);\n        }\n      }\n\n      return this;\n    }\n    /**\n     * Method used to clear the canvases.\n     *\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.contexts.nodes.clear(this.contexts.nodes.COLOR_BUFFER_BIT);\n      this.contexts.edges.clear(this.contexts.edges.COLOR_BUFFER_BIT);\n      this.contexts.labels.clearRect(0, 0, this.width, this.height);\n      this.contexts.hovers.clearRect(0, 0, this.width, this.height);\n      this.contexts.edgeLabels.clearRect(0, 0, this.width, this.height);\n      return this;\n    }\n    /**\n     * Method used to render.\n     *\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      // If a render was scheduled, we cancel it\n      if (this.renderFrame) {\n        cancelAnimationFrame(this.renderFrame);\n        this.renderFrame = null;\n        this.needToProcess = false;\n        this.needToSoftProcess = false;\n      } // First we need to resize\n\n\n      this.resize(); // Clearing the canvases\n\n      this.clear(); // If we have no nodes we can stop right there\n\n      if (!this.graph.order) return this; // TODO: improve this heuristic or move to the captor itself?\n\n      var moving = this.camera.isAnimated() || this.captors.mouse.isMoving || this.captors.mouse.hasDragged || this.captors.mouse.wheelLock; // Then we need to extract a matrix from the camera\n\n      var cameraState = this.camera.getState(),\n          cameraMatrix = (0, _utils3.matrixFromCamera)(cameraState, {\n        width: this.width,\n        height: this.height\n      });\n      var program; // Drawing nodes\n\n      program = this.nodePrograms[this.settings.defaultNodeType];\n      program.render({\n        matrix: cameraMatrix,\n        width: this.width,\n        height: this.height,\n        ratio: cameraState.ratio,\n        nodesPowRatio: 0.5,\n        scalingRatio: WEBGL_OVERSAMPLING_RATIO\n      }); // Drawing edges\n\n      if (!this.settings.hideEdgesOnMove || !moving) {\n        program = this.edgePrograms[this.settings.defaultEdgeType];\n        program.render({\n          matrix: cameraMatrix,\n          width: this.width,\n          height: this.height,\n          ratio: cameraState.ratio,\n          nodesPowRatio: 0.5,\n          edgesPowRatio: 0.5,\n          scalingRatio: WEBGL_OVERSAMPLING_RATIO\n        });\n      } // Do not display labels on move per setting\n\n\n      if (this.settings.hideLabelsOnMove && moving) return this;\n      this.renderLabels();\n      this.renderEdgeLabels();\n      this.renderHighlightedNodes();\n      return this;\n    }\n    /**\n     * Method used to render labels.\n     *\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"renderLabels\",\n    value: function renderLabels() {\n      if (!this.settings.renderLabels) return this;\n      var cameraState = this.camera.getState(); // Finding visible nodes to display their labels\n\n      var visibleNodes;\n\n      if (cameraState.ratio >= 1) {\n        // Camera is unzoomed so no need to ask the quadtree for visible nodes\n        visibleNodes = this.graph.nodes();\n      } else {\n        // Let's ask the quadtree\n        var viewRectangle = this.camera.viewRectangle(this);\n        visibleNodes = this.quadtree.rectangle(viewRectangle.x1, 1 - viewRectangle.y1, viewRectangle.x2, 1 - viewRectangle.y2, viewRectangle.height);\n      } // Selecting labels to draw\n\n\n      var gridSettings = this.settings.labelGrid;\n      var labelsToDisplay = (0, _labels.labelsToDisplayFromGrid)({\n        cache: this.nodeDataCache,\n        camera: this.camera,\n        cell: gridSettings.cell,\n        dimensions: this,\n        displayedLabels: this.displayedLabels,\n        fontSize: this.settings.labelSize,\n        graph: this.graph,\n        renderedSizeThreshold: gridSettings.renderedSizeThreshold,\n        visibleNodes: visibleNodes\n      }); // Drawing labels\n\n      var context = this.contexts.labels;\n      var sizeRatio = Math.pow(cameraState.ratio, 0.5);\n\n      for (var i = 0, l = labelsToDisplay.length; i < l; i++) {\n        var data = this.nodeDataCache[labelsToDisplay[i]];\n\n        var _this$camera$graphToV = this.camera.graphToViewport(this, data.x, data.y),\n            x = _this$camera$graphToV.x,\n            y = _this$camera$graphToV.y; // TODO: we can cache the labels we need to render until the camera's ratio changes\n        // TODO: this should be computed in the canvas components?\n\n\n        var size = data.size / sizeRatio;\n        this.settings.labelRenderer(context, {\n          key: labelsToDisplay[i],\n          label: data.label,\n          size: size,\n          x: x,\n          y: y\n        }, this.settings);\n      } // Caching visible nodes and displayed labels\n\n\n      this.displayedLabels = new Set(labelsToDisplay);\n      return this;\n    }\n    /**\n     * Method used to render edge labels, based on which node labels were\n     * rendered.\n     *\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"renderEdgeLabels\",\n    value: function renderEdgeLabels() {\n      if (!this.settings.renderEdgeLabels) return this;\n      var cameraState = this.camera.getState();\n      var sizeRatio = Math.pow(cameraState.ratio, 0.5);\n      var context = this.contexts.edgeLabels; // Clearing\n\n      context.clearRect(0, 0, this.width, this.height);\n      var edgeLabelsToDisplay = (0, _labels.edgeLabelsToDisplayFromNodes)({\n        graph: this.graph,\n        hoveredNode: this.hoveredNode,\n        displayedNodeLabels: this.displayedLabels,\n        highlightedNodes: this.highlightedNodes\n      });\n\n      for (var i = 0, l = edgeLabelsToDisplay.length; i < l; i++) {\n        var edge = edgeLabelsToDisplay[i],\n            extremities = this.graph.extremities(edge),\n            sourceData = this.nodeDataCache[extremities[0]],\n            targetData = this.nodeDataCache[extremities[1]],\n            edgeData = this.edgeDataCache[edgeLabelsToDisplay[i]];\n\n        var _this$camera$graphToV2 = this.camera.graphToViewport(this, sourceData.x, sourceData.y),\n            sourceX = _this$camera$graphToV2.x,\n            sourceY = _this$camera$graphToV2.y;\n\n        var _this$camera$graphToV3 = this.camera.graphToViewport(this, targetData.x, targetData.y),\n            targetX = _this$camera$graphToV3.x,\n            targetY = _this$camera$graphToV3.y; // TODO: we can cache the labels we need to render until the camera's ratio changes\n        // TODO: this should be computed in the canvas components?\n\n\n        var size = edgeData.size / sizeRatio;\n        this.settings.edgeLabelRenderer(context, {\n          key: edge,\n          label: edgeData.label,\n          color: edgeData.color,\n          size: size\n        }, {\n          key: extremities[0],\n          x: sourceX,\n          y: sourceY\n        }, {\n          key: extremities[1],\n          x: targetX,\n          y: targetY\n        }, this.settings);\n      }\n\n      return this;\n    }\n    /**\n     * Method used to render the highlighted nodes.\n     *\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"renderHighlightedNodes\",\n    value: function renderHighlightedNodes() {\n      var _this5 = this;\n\n      var camera = this.camera;\n      var sizeRatio = Math.pow(camera.getState().ratio, 0.5);\n      var context = this.contexts.hovers; // Clearing\n\n      context.clearRect(0, 0, this.width, this.height); // Rendering\n\n      var render = function render(node) {\n        var data = _this5.nodeDataCache[node];\n\n        var _camera$graphToViewpo = camera.graphToViewport(_this5, data.x, data.y),\n            x = _camera$graphToViewpo.x,\n            y = _camera$graphToViewpo.y;\n\n        var size = data.size / sizeRatio;\n\n        _this5.settings.hoverRenderer(context, {\n          key: node,\n          label: data.label,\n          color: data.color,\n          size: size,\n          x: x,\n          y: y\n        }, _this5.settings);\n      };\n\n      if (this.hoveredNode) render(this.hoveredNode);\n      this.highlightedNodes.forEach(render);\n    }\n    /**\n     * Method used to schedule a render.\n     *\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"scheduleRender\",\n    value: function scheduleRender() {\n      var _this6 = this;\n\n      // A frame is already scheduled\n      if (this.renderFrame) return this; // Let's schedule a frame\n\n      this.renderFrame = requestAnimationFrame(function () {\n        // Do we need to process data?\n        if (_this6.needToProcess) {\n          _this6.process();\n        } else if (_this6.needToSoftProcess) {\n          _this6.process(true);\n        } // Resetting state\n\n\n        _this6.renderFrame = null;\n        _this6.needToProcess = false;\n        _this6.needToSoftProcess = false; // Rendering\n\n        _this6.render();\n      });\n    }\n    /**\n     * Method used to schedule a hover render.\n     *\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"scheduleHighlightedNodesRender\",\n    value: function scheduleHighlightedNodesRender() {\n      var _this7 = this;\n\n      if (this.renderHighlightedNodesFrame || this.renderFrame) return this;\n      this.renderHighlightedNodesFrame = requestAnimationFrame(function () {\n        // Resetting state\n        _this7.renderHighlightedNodesFrame = null; // Rendering\n\n        _this7.renderHighlightedNodes();\n\n        _this7.renderEdgeLabels();\n      });\n    }\n    /**\n     * Method used to manually refresh.\n     *\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      this.needToSoftProcess = true;\n      this.scheduleRender();\n      return this;\n    }\n    /**\n     * Method used to highlight a node.\n     *\n     * @param  {string} key - The node's key.\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"highlightNode\",\n    value: function highlightNode(key) {\n      // TODO: check the existence of the node\n      // TODO: coerce?\n      this.highlightedNodes.add(key); // Rendering\n\n      this.scheduleHighlightedNodesRender();\n      return this;\n    }\n    /**\n     * Method used to unhighlight a node.\n     *\n     * @param  {string} key - The node's key.\n     * @return {WebGLRenderer}\n     */\n\n  }, {\n    key: \"unhighlightNode\",\n    value: function unhighlightNode(key) {\n      // TODO: check the existence of the node\n      // TODO: coerce?\n      this.highlightedNodes[\"delete\"](key); // Rendering\n\n      this.scheduleHighlightedNodesRender();\n      return this;\n    }\n    /**\n     * Method used to shut the container & release event listeners.\n     *\n     * @return {undefined}\n     */\n\n  }, {\n    key: \"kill\",\n    value: function kill() {\n      var graph = this.graph; // Releasing camera handlers\n\n      this.camera.removeListener('updated', this.listeners.camera); // Releasing DOM events & captors\n\n      window.removeEventListener('resize', this.listeners.handleResize);\n      this.captors.mouse.kill(); // Releasing graph handlers\n\n      graph.removeListener('nodeAdded', this.listeners.addNodeGraphUpdate);\n      graph.removeListener('nodeDropped', this.listeners.graphUpdate);\n      graph.removeListener('nodeAttributesUpdated', this.listeners.softGraphUpdate);\n      graph.removeListener('edgeAdded', this.listeners.addEdgeGraphUpdate);\n      graph.removeListener('nodeDropped', this.listeners.graphUpdate);\n      graph.removeListener('edgeAttributesUpdated', this.listeners.softGraphUpdate);\n      graph.removeListener('cleared', this.listeners.graphUpdate); // Releasing cache & state\n\n      this.quadtree = null;\n      this.nodeDataCache = null;\n      this.edgeDataCache = null;\n      this.highlightedNodes = null;\n      this.previousVisibleNodes = null;\n      this.displayedLabels = null; // Clearing frames\n\n      if (this.renderFrame) {\n        cancelAnimationFrame(this.renderFrame);\n        this.renderFrame = null;\n      }\n\n      if (this.renderHighlightedNodesFrame) {\n        cancelAnimationFrame(this.renderHighlightedNodesFrame);\n        this.renderHighlightedNodesFrame = null;\n      } // Destroying canvases\n\n\n      var container = this.container;\n\n      while (container.firstChild) {\n        container.removeChild(container.firstChild);\n      }\n    }\n  }]);\n\n  return WebGLRenderer;\n}(_renderer[\"default\"]);\n\nexports[\"default\"] = WebGLRenderer;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.identity = identity;\nexports.scale = scale;\nexports.rotate = rotate;\nexports.translate = translate;\nexports.multiply = multiply;\n\n/**\n * Sigma.js WebGL Matrices Helpers\n * ================================\n *\n * Matrices-related helper functions used by sigma's WebGL renderer.\n */\nfunction identity() {\n  return Float32Array.of(1, 0, 0, 0, 1, 0, 0, 0, 1);\n} // TODO: optimize\n\n\nfunction scale(m, x, y) {\n  m[0] = x;\n  m[4] = arguments.length > 2 ? y : x;\n  return m;\n}\n\nfunction rotate(m, r) {\n  var s = Math.sin(r),\n      c = Math.cos(r);\n  m[0] = c;\n  m[1] = s;\n  m[3] = -s;\n  m[4] = c;\n  return m;\n}\n\nfunction translate(m, x, y) {\n  m[6] = x;\n  m[7] = y;\n  return m;\n}\n\nfunction multiply(a, b) {\n  var a00 = a[0],\n      a01 = a[1],\n      a02 = a[2];\n  var a10 = a[3],\n      a11 = a[4],\n      a12 = a[5];\n  var a20 = a[6],\n      a21 = a[7],\n      a22 = a[8];\n  var b00 = b[0],\n      b01 = b[1],\n      b02 = b[2];\n  var b10 = b[3],\n      b11 = b[4],\n      b12 = b[5];\n  var b20 = b[6],\n      b21 = b[7],\n      b22 = b[8];\n  a[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  a[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  a[2] = b00 * a02 + b01 * a12 + b02 * a22;\n  a[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  a[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  a[5] = b10 * a02 + b11 * a12 + b12 * a22;\n  a[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  a[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  a[8] = b20 * a02 + b21 * a12 + b22 * a22;\n  return a;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _program = _interopRequireDefault(require(\"./program\"));\n\nvar _utils = require(\"../utils\");\n\nvar _arrowVert = _interopRequireDefault(require(\"../shaders/arrow.vert.glsl\"));\n\nvar _arrowFrag = _interopRequireDefault(require(\"../shaders/arrow.frag.glsl\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar POINTS = 3,\n    ATTRIBUTES = 10,\n    STRIDE = POINTS * ATTRIBUTES;\n\nvar ArrowProgram =\n/*#__PURE__*/\nfunction (_Program) {\n  _inherits(ArrowProgram, _Program);\n\n  function ArrowProgram(gl) {\n    var _this;\n\n    _classCallCheck(this, ArrowProgram);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ArrowProgram).call(this, gl, _arrowVert[\"default\"], _arrowFrag[\"default\"])); // Binding context\n\n    _this.gl = gl; // Array data\n\n    _this.array = null; // Initializing buffers\n\n    _this.buffer = gl.createBuffer(); // Locations\n\n    _this.positionLocation = gl.getAttribLocation(_this.program, 'a_position');\n    _this.normalLocation = gl.getAttribLocation(_this.program, 'a_normal');\n    _this.thicknessLocation = gl.getAttribLocation(_this.program, 'a_thickness');\n    _this.radiusLocation = gl.getAttribLocation(_this.program, 'a_radius');\n    _this.colorLocation = gl.getAttribLocation(_this.program, 'a_color');\n    _this.barycentricLocation = gl.getAttribLocation(_this.program, 'a_barycentric');\n    _this.resolutionLocation = gl.getUniformLocation(_this.program, 'u_resolution');\n    _this.ratioLocation = gl.getUniformLocation(_this.program, 'u_ratio');\n    _this.matrixLocation = gl.getUniformLocation(_this.program, 'u_matrix');\n    _this.scaleLocation = gl.getUniformLocation(_this.program, 'u_scale');\n\n    _this.bind();\n\n    return _this;\n  }\n\n  _createClass(ArrowProgram, [{\n    key: \"bind\",\n    value: function bind() {\n      var gl = this.gl;\n      gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer); // Bindings\n\n      gl.enableVertexAttribArray(this.positionLocation);\n      gl.enableVertexAttribArray(this.normalLocation);\n      gl.enableVertexAttribArray(this.thicknessLocation);\n      gl.enableVertexAttribArray(this.radiusLocation);\n      gl.enableVertexAttribArray(this.colorLocation);\n      gl.enableVertexAttribArray(this.barycentricLocation);\n      gl.vertexAttribPointer(this.positionLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 0);\n      gl.vertexAttribPointer(this.normalLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 8);\n      gl.vertexAttribPointer(this.thicknessLocation, 1, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 16);\n      gl.vertexAttribPointer(this.radiusLocation, 1, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 20);\n      gl.vertexAttribPointer(this.colorLocation, 4, gl.UNSIGNED_BYTE, true, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 24); // TODO: maybe we can optimize here by packing this in a bit mask\n\n      gl.vertexAttribPointer(this.barycentricLocation, 3, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 28);\n    }\n  }, {\n    key: \"allocate\",\n    value: function allocate(capacity) {\n      this.array = new Float32Array(POINTS * ATTRIBUTES * capacity);\n    }\n  }, {\n    key: \"process\",\n    value: function process(sourceData, targetData, data, offset) {\n      if (sourceData.hidden || targetData.hidden || data.hidden) {\n        for (var _i = offset * STRIDE, l = _i + STRIDE; _i < l; _i++) {\n          this.array[_i] = 0;\n        }\n\n        return;\n      }\n\n      var thickness = Math.max((data.size || 1) * 2.5, 5),\n          radius = targetData.size || 1,\n          x1 = sourceData.x,\n          y1 = sourceData.y,\n          x2 = targetData.x,\n          y2 = targetData.y,\n          color = (0, _utils.floatColor)(data.color); // Computing normals\n\n      var dx = x2 - x1,\n          dy = y2 - y1;\n      var len = dx * dx + dy * dy,\n          n1 = 0,\n          n2 = 0;\n\n      if (len) {\n        len = 1 / Math.sqrt(len);\n        n1 = -dy * len;\n        n2 = dx * len;\n      }\n\n      var i = POINTS * ATTRIBUTES * offset;\n      var array = this.array; // First point\n\n      array[i++] = x2;\n      array[i++] = y2;\n      array[i++] = -n1;\n      array[i++] = -n2;\n      array[i++] = thickness;\n      array[i++] = radius;\n      array[i++] = color;\n      array[i++] = 1;\n      array[i++] = 0;\n      array[i++] = 0; // Second point\n\n      array[i++] = x2;\n      array[i++] = y2;\n      array[i++] = -n1;\n      array[i++] = -n2;\n      array[i++] = thickness;\n      array[i++] = radius;\n      array[i++] = color;\n      array[i++] = 0;\n      array[i++] = 1;\n      array[i++] = 0; // Third point\n\n      array[i++] = x2;\n      array[i++] = y2;\n      array[i++] = -n1;\n      array[i++] = -n2;\n      array[i++] = thickness;\n      array[i++] = radius;\n      array[i++] = color;\n      array[i++] = 0;\n      array[i++] = 0;\n      array[i] = 1;\n    }\n  }, {\n    key: \"bufferData\",\n    value: function bufferData() {\n      var gl = this.gl; // Vertices data\n\n      gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW);\n    }\n  }, {\n    key: \"render\",\n    value: function render(params) {\n      var gl = this.gl;\n      var program = this.program;\n      gl.useProgram(program); // Binding uniforms\n\n      gl.uniform2f(this.resolutionLocation, params.width, params.height);\n      gl.uniform1f(this.ratioLocation, params.ratio);\n      gl.uniformMatrix3fv(this.matrixLocation, false, params.matrix);\n      gl.uniform1f(this.scaleLocation, params.scalingRatio); // Drawing:\n\n      gl.drawArrays(gl.TRIANGLES, 0, this.array.length / ATTRIBUTES);\n    }\n  }]);\n\n  return ArrowProgram;\n}(_program[\"default\"]);\n\nexports[\"default\"] = ArrowProgram;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _program = require(\"./program\");\n\nvar _arrow = _interopRequireDefault(require(\"./arrow\"));\n\nvar _edge = _interopRequireDefault(require(\"./edge.clamped\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/**\n * Sigma.js WebGL Renderer Edge Arrow Program\n * ===========================================\n *\n * Compound program rendering edges as an arrow from the source to the target.\n */\nvar program = (0, _program.createCompoundProgram)([_edge[\"default\"], _arrow[\"default\"]]);\nvar _default = program;\nexports[\"default\"] = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _program = _interopRequireDefault(require(\"./program\"));\n\nvar _utils = require(\"../utils\");\n\nvar _edgeClampedVert = _interopRequireDefault(require(\"../shaders/edge.clamped.vert.glsl\"));\n\nvar _edgeFrag = _interopRequireDefault(require(\"../shaders/edge.frag.glsl\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar POINTS = 4,\n    ATTRIBUTES = 7,\n    STRIDE = POINTS * ATTRIBUTES;\n\nvar EdgeClampedProgram =\n/*#__PURE__*/\nfunction (_Program) {\n  _inherits(EdgeClampedProgram, _Program);\n\n  function EdgeClampedProgram(gl) {\n    var _this;\n\n    _classCallCheck(this, EdgeClampedProgram);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(EdgeClampedProgram).call(this, gl, _edgeClampedVert[\"default\"], _edgeFrag[\"default\"])); // Binding context\n\n    _this.gl = gl; // Array data\n\n    _this.array = null;\n    _this.indicesArray = null; // Initializing buffers\n\n    _this.buffer = gl.createBuffer();\n    _this.indicesBuffer = gl.createBuffer(); // Locations\n\n    _this.positionLocation = gl.getAttribLocation(_this.program, 'a_position');\n    _this.normalLocation = gl.getAttribLocation(_this.program, 'a_normal');\n    _this.thicknessLocation = gl.getAttribLocation(_this.program, 'a_thickness');\n    _this.colorLocation = gl.getAttribLocation(_this.program, 'a_color');\n    _this.radiusLocation = gl.getAttribLocation(_this.program, 'a_radius');\n    _this.resolutionLocation = gl.getUniformLocation(_this.program, 'u_resolution');\n    _this.ratioLocation = gl.getUniformLocation(_this.program, 'u_ratio');\n    _this.matrixLocation = gl.getUniformLocation(_this.program, 'u_matrix');\n    _this.scaleLocation = gl.getUniformLocation(_this.program, 'u_scale');\n\n    _this.bind(); // Enabling the OES_element_index_uint extension\n    // NOTE: on older GPUs, this means that really large graphs won't\n    // have all their edges rendered. But it seems that the\n    // `OES_element_index_uint` is quite everywhere so we'll handle\n    // the potential issue if it really arises.\n    // NOTE: when using webgl2, the extension is enabled by default\n\n\n    _this.canUse32BitsIndices = (0, _utils.canUse32BitsIndices)(gl);\n    _this.IndicesArray = _this.canUse32BitsIndices ? Uint32Array : Uint16Array;\n    _this.indicesType = _this.canUse32BitsIndices ? gl.UNSIGNED_INT : gl.UNSIGNED_SHORT;\n    return _this;\n  }\n\n  _createClass(EdgeClampedProgram, [{\n    key: \"bind\",\n    value: function bind() {\n      var gl = this.gl;\n      gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer); // Bindings\n\n      gl.enableVertexAttribArray(this.positionLocation);\n      gl.enableVertexAttribArray(this.normalLocation);\n      gl.enableVertexAttribArray(this.thicknessLocation);\n      gl.enableVertexAttribArray(this.colorLocation);\n      gl.enableVertexAttribArray(this.radiusLocation);\n      gl.vertexAttribPointer(this.positionLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 0);\n      gl.vertexAttribPointer(this.normalLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 8);\n      gl.vertexAttribPointer(this.thicknessLocation, 1, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 16);\n      gl.vertexAttribPointer(this.colorLocation, 4, gl.UNSIGNED_BYTE, true, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 20);\n      gl.vertexAttribPointer(this.radiusLocation, 1, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 24);\n    }\n  }, {\n    key: \"allocate\",\n    value: function allocate(capacity) {\n      this.array = new Float32Array(POINTS * ATTRIBUTES * capacity);\n    }\n  }, {\n    key: \"process\",\n    value: function process(sourceData, targetData, data, offset) {\n      if (sourceData.hidden || targetData.hidden || data.hidden) {\n        for (var _i = offset * STRIDE, l = _i + STRIDE; _i < l; _i++) {\n          this.array[_i] = 0;\n        }\n\n        return;\n      }\n\n      var thickness = data.size || 1,\n          x1 = sourceData.x,\n          y1 = sourceData.y,\n          x2 = targetData.x,\n          y2 = targetData.y,\n          radius = targetData.size || 1,\n          color = (0, _utils.floatColor)(data.color); // Computing normals\n\n      var dx = x2 - x1,\n          dy = y2 - y1;\n      var len = dx * dx + dy * dy,\n          n1 = 0,\n          n2 = 0;\n\n      if (len) {\n        len = 1 / Math.sqrt(len);\n        n1 = -dy * len;\n        n2 = dx * len;\n      }\n\n      var i = POINTS * ATTRIBUTES * offset;\n      var array = this.array; // First point\n\n      array[i++] = x1;\n      array[i++] = y1;\n      array[i++] = n1;\n      array[i++] = n2;\n      array[i++] = thickness;\n      array[i++] = color;\n      array[i++] = 0; // First point flipped\n\n      array[i++] = x1;\n      array[i++] = y1;\n      array[i++] = -n1;\n      array[i++] = -n2;\n      array[i++] = thickness;\n      array[i++] = color;\n      array[i++] = 0; // Second point\n\n      array[i++] = x2;\n      array[i++] = y2;\n      array[i++] = n1;\n      array[i++] = n2;\n      array[i++] = thickness;\n      array[i++] = color;\n      array[i++] = radius; // Second point flipped\n\n      array[i++] = x2;\n      array[i++] = y2;\n      array[i++] = -n1;\n      array[i++] = -n2;\n      array[i++] = thickness;\n      array[i++] = color;\n      array[i] = -radius;\n    }\n  }, {\n    key: \"computeIndices\",\n    value: function computeIndices() {\n      var l = this.array.length / ATTRIBUTES;\n      var size = l + l / 2;\n      var indices = new this.IndicesArray(size);\n\n      for (var i = 0, c = 0; i < l; i += 4) {\n        indices[c++] = i;\n        indices[c++] = i + 1;\n        indices[c++] = i + 2;\n        indices[c++] = i + 2;\n        indices[c++] = i + 1;\n        indices[c++] = i + 3;\n      }\n\n      this.indicesArray = indices;\n    }\n  }, {\n    key: \"bufferData\",\n    value: function bufferData() {\n      var gl = this.gl; // Vertices data\n\n      gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW); // Indices data\n\n      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indicesArray, gl.STATIC_DRAW);\n    }\n  }, {\n    key: \"render\",\n    value: function render(params) {\n      var gl = this.gl;\n      var program = this.program;\n      gl.useProgram(program); // Binding uniforms\n      // TODO: precise the uniform names\n\n      gl.uniform2f(this.resolutionLocation, params.width, params.height);\n      gl.uniform1f(this.ratioLocation, // 1 / Math.pow(params.ratio, params.edgesPowRatio)\n      params.ratio);\n      gl.uniformMatrix3fv(this.matrixLocation, false, params.matrix);\n      gl.uniform1f(this.scaleLocation, params.scalingRatio); // Drawing:\n\n      gl.drawElements(gl.TRIANGLES, this.indicesArray.length, this.indicesType, 0);\n    }\n  }]);\n\n  return EdgeClampedProgram;\n}(_program[\"default\"]);\n\nexports[\"default\"] = EdgeClampedProgram;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _program = _interopRequireDefault(require(\"./program\"));\n\nvar _utils = require(\"../utils\");\n\nvar _edgeVert = _interopRequireDefault(require(\"../shaders/edge.vert.glsl\"));\n\nvar _edgeFrag = _interopRequireDefault(require(\"../shaders/edge.frag.glsl\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar POINTS = 4,\n    ATTRIBUTES = 6,\n    STRIDE = POINTS * ATTRIBUTES;\n\nvar EdgeProgram =\n/*#__PURE__*/\nfunction (_Program) {\n  _inherits(EdgeProgram, _Program);\n\n  function EdgeProgram(gl) {\n    var _this;\n\n    _classCallCheck(this, EdgeProgram);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(EdgeProgram).call(this, gl, _edgeVert[\"default\"], _edgeFrag[\"default\"])); // Binding context\n\n    _this.gl = gl; // Array data\n\n    _this.array = null;\n    _this.indicesArray = null; // Initializing buffers\n\n    _this.buffer = gl.createBuffer();\n    _this.indicesBuffer = gl.createBuffer(); // Locations\n\n    _this.positionLocation = gl.getAttribLocation(_this.program, 'a_position');\n    _this.normalLocation = gl.getAttribLocation(_this.program, 'a_normal');\n    _this.thicknessLocation = gl.getAttribLocation(_this.program, 'a_thickness');\n    _this.colorLocation = gl.getAttribLocation(_this.program, 'a_color');\n    _this.resolutionLocation = gl.getUniformLocation(_this.program, 'u_resolution');\n    _this.ratioLocation = gl.getUniformLocation(_this.program, 'u_ratio');\n    _this.matrixLocation = gl.getUniformLocation(_this.program, 'u_matrix');\n    _this.scaleLocation = gl.getUniformLocation(_this.program, 'u_scale');\n\n    _this.bind(); // Enabling the OES_element_index_uint extension\n    // NOTE: on older GPUs, this means that really large graphs won't\n    // have all their edges rendered. But it seems that the\n    // `OES_element_index_uint` is quite everywhere so we'll handle\n    // the potential issue if it really arises.\n    // NOTE: when using webgl2, the extension is enabled by default\n\n\n    _this.canUse32BitsIndices = (0, _utils.canUse32BitsIndices)(gl);\n    _this.IndicesArray = _this.canUse32BitsIndices ? Uint32Array : Uint16Array;\n    _this.indicesType = _this.canUse32BitsIndices ? gl.UNSIGNED_INT : gl.UNSIGNED_SHORT;\n    return _this;\n  }\n\n  _createClass(EdgeProgram, [{\n    key: \"bind\",\n    value: function bind() {\n      var gl = this.gl;\n      gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indicesBuffer); // Bindings\n\n      gl.enableVertexAttribArray(this.positionLocation);\n      gl.enableVertexAttribArray(this.normalLocation);\n      gl.enableVertexAttribArray(this.thicknessLocation);\n      gl.enableVertexAttribArray(this.colorLocation);\n      gl.vertexAttribPointer(this.positionLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 0);\n      gl.vertexAttribPointer(this.normalLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 8);\n      gl.vertexAttribPointer(this.thicknessLocation, 1, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 16);\n      gl.vertexAttribPointer(this.colorLocation, 4, gl.UNSIGNED_BYTE, true, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 20);\n    }\n  }, {\n    key: \"allocate\",\n    value: function allocate(capacity) {\n      this.array = new Float32Array(POINTS * ATTRIBUTES * capacity);\n    }\n  }, {\n    key: \"process\",\n    value: function process(sourceData, targetData, data, offset) {\n      if (sourceData.hidden || targetData.hidden || data.hidden) {\n        for (var _i = offset * STRIDE, l = _i + STRIDE; _i < l; _i++) {\n          this.array[_i] = 0;\n        }\n\n        return;\n      }\n\n      var thickness = data.size || 1,\n          x1 = sourceData.x,\n          y1 = sourceData.y,\n          x2 = targetData.x,\n          y2 = targetData.y,\n          color = (0, _utils.floatColor)(data.color); // Computing normals\n\n      var dx = x2 - x1,\n          dy = y2 - y1;\n      var len = dx * dx + dy * dy,\n          n1 = 0,\n          n2 = 0;\n\n      if (len) {\n        len = 1 / Math.sqrt(len);\n        n1 = -dy * len;\n        n2 = dx * len;\n      }\n\n      var i = POINTS * ATTRIBUTES * offset;\n      var array = this.array; // First point\n\n      array[i++] = x1;\n      array[i++] = y1;\n      array[i++] = n1;\n      array[i++] = n2;\n      array[i++] = thickness;\n      array[i++] = color; // First point flipped\n\n      array[i++] = x1;\n      array[i++] = y1;\n      array[i++] = -n1;\n      array[i++] = -n2;\n      array[i++] = thickness;\n      array[i++] = color; // Second point\n\n      array[i++] = x2;\n      array[i++] = y2;\n      array[i++] = n1;\n      array[i++] = n2;\n      array[i++] = thickness;\n      array[i++] = color; // Second point flipped\n\n      array[i++] = x2;\n      array[i++] = y2;\n      array[i++] = -n1;\n      array[i++] = -n2;\n      array[i++] = thickness;\n      array[i] = color;\n    }\n  }, {\n    key: \"computeIndices\",\n    value: function computeIndices() {\n      var l = this.array.length / ATTRIBUTES;\n      var size = l + l / 2;\n      var indices = new this.IndicesArray(size);\n\n      for (var i = 0, c = 0; i < l; i += 4) {\n        indices[c++] = i;\n        indices[c++] = i + 1;\n        indices[c++] = i + 2;\n        indices[c++] = i + 2;\n        indices[c++] = i + 1;\n        indices[c++] = i + 3;\n      }\n\n      this.indicesArray = indices;\n    }\n  }, {\n    key: \"bufferData\",\n    value: function bufferData() {\n      var gl = this.gl; // Vertices data\n\n      gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW); // Indices data\n\n      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indicesArray, gl.STATIC_DRAW);\n    }\n  }, {\n    key: \"render\",\n    value: function render(params) {\n      var gl = this.gl;\n      var program = this.program;\n      gl.useProgram(program); // Binding uniforms\n      // TODO: precise the uniform names\n\n      gl.uniform2f(this.resolutionLocation, params.width, params.height);\n      gl.uniform1f(this.ratioLocation, // 1 / Math.pow(params.ratio, params.edgesPowRatio)\n      params.ratio);\n      gl.uniformMatrix3fv(this.matrixLocation, false, params.matrix);\n      gl.uniform1f(this.scaleLocation, params.scalingRatio); // Drawing:\n\n      gl.drawElements(gl.TRIANGLES, this.indicesArray.length, this.indicesType, 0);\n    }\n  }]);\n\n  return EdgeProgram;\n}(_program[\"default\"]);\n\nexports[\"default\"] = EdgeProgram;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _program = _interopRequireDefault(require(\"./program\"));\n\nvar _utils = require(\"../utils\");\n\nvar _nodeFastVert = _interopRequireDefault(require(\"../shaders/node.fast.vert.glsl\"));\n\nvar _nodeFastFrag = _interopRequireDefault(require(\"../shaders/node.fast.frag.glsl\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar POINTS = 1,\n    ATTRIBUTES = 4;\n\nvar NodeProgramFast =\n/*#__PURE__*/\nfunction (_Program) {\n  _inherits(NodeProgramFast, _Program);\n\n  function NodeProgramFast(gl) {\n    var _this;\n\n    _classCallCheck(this, NodeProgramFast);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeProgramFast).call(this, gl, _nodeFastVert[\"default\"], _nodeFastFrag[\"default\"])); // Binding context\n\n    _this.gl = gl; // Array data\n\n    _this.array = null; // Initializing buffers\n\n    _this.buffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, _this.buffer);\n    var program = _this.program; // Locations\n\n    _this.positionLocation = gl.getAttribLocation(program, 'a_position');\n    _this.sizeLocation = gl.getAttribLocation(program, 'a_size');\n    _this.colorLocation = gl.getAttribLocation(program, 'a_color');\n    _this.matrixLocation = gl.getUniformLocation(program, 'u_matrix');\n    _this.ratioLocation = gl.getUniformLocation(program, 'u_ratio');\n    _this.scaleLocation = gl.getUniformLocation(program, 'u_scale'); // Bindings\n\n    gl.enableVertexAttribArray(_this.positionLocation);\n    gl.enableVertexAttribArray(_this.sizeLocation);\n    gl.enableVertexAttribArray(_this.colorLocation);\n    gl.vertexAttribPointer(_this.positionLocation, 2, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 0);\n    gl.vertexAttribPointer(_this.sizeLocation, 1, gl.FLOAT, false, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 8);\n    gl.vertexAttribPointer(_this.colorLocation, 4, gl.UNSIGNED_BYTE, true, ATTRIBUTES * Float32Array.BYTES_PER_ELEMENT, 12);\n    return _this;\n  }\n\n  _createClass(NodeProgramFast, [{\n    key: \"allocate\",\n    value: function allocate(capacity) {\n      this.array = new Float32Array(POINTS * ATTRIBUTES * capacity);\n    }\n  }, {\n    key: \"process\",\n    value: function process(data, offset) {\n      var color = (0, _utils.floatColor)(data.color);\n      var i = offset * POINTS * ATTRIBUTES;\n      var array = this.array;\n\n      if (data.hidden) {\n        array[i++] = 0;\n        array[i++] = 0;\n        array[i++] = 0;\n        array[i++] = 0;\n        return;\n      }\n\n      array[i++] = data.x;\n      array[i++] = data.y;\n      array[i++] = data.size;\n      array[i] = color;\n    }\n  }, {\n    key: \"bufferData\",\n    value: function bufferData() {\n      var gl = this.gl;\n      gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW);\n    }\n  }, {\n    key: \"render\",\n    value: function render(params) {\n      var gl = this.gl;\n      var program = this.program;\n      gl.useProgram(program);\n      gl.uniform1f(this.ratioLocation, 1 / Math.pow(params.ratio, params.nodesPowRatio));\n      gl.uniform1f(this.scaleLocation, params.scalingRatio);\n      gl.uniformMatrix3fv(this.matrixLocation, false, params.matrix);\n      gl.drawArrays(gl.POINTS, 0, this.array.length / ATTRIBUTES);\n    }\n  }]);\n\n  return NodeProgramFast;\n}(_program[\"default\"]);\n\nexports[\"default\"] = NodeProgramFast;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createCompoundProgram = createCompoundProgram;\nexports[\"default\"] = void 0;\n\nvar _utils = require(\"../shaders/utils\");\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * Program class.\n *\n * @constructor\n */\nvar Program =\n/*#__PURE__*/\nfunction () {\n  function Program(gl, vertexShaderSource, fragmentShaderSource) {\n    _classCallCheck(this, Program);\n\n    this.vertexShaderSource = vertexShaderSource;\n    this.fragmentShaderSource = fragmentShaderSource;\n    this.load(gl);\n  }\n  /**\n   * Method used to load the program into a webgl context.\n   *\n   * @param  {WebGLContext} gl - The WebGL context.\n   * @return {WebGLProgram}\n   */\n\n\n  _createClass(Program, [{\n    key: \"load\",\n    value: function load(gl) {\n      this.vertexShader = (0, _utils.loadVertexShader)(gl, this.vertexShaderSource);\n      this.fragmentShader = (0, _utils.loadFragmentShader)(gl, this.fragmentShaderSource);\n      this.program = (0, _utils.loadProgram)(gl, [this.vertexShader, this.fragmentShader]);\n      return this.program;\n    }\n  }]);\n\n  return Program;\n}();\n/**\n * Helper function combining two or more programs into a single compound one.\n * Note that this is more a quick & easy way to combine program than a really\n * performant option. More performant programs can be written entirely.\n *\n * @param  {array}    programClasses - Program classes to combine.\n * @return {function}\n */\n// TODO: maybe those should handle their own canvases\n\n\nexports[\"default\"] = Program;\n\nfunction createCompoundProgram(programClasses) {\n  return (\n    /*#__PURE__*/\n    function () {\n      function CompoundProgram(gl) {\n        _classCallCheck(this, CompoundProgram);\n\n        this.programs = programClasses.map(function (ProgramClass) {\n          return new ProgramClass(gl);\n        });\n      }\n\n      _createClass(CompoundProgram, [{\n        key: \"allocate\",\n        value: function allocate(capacity) {\n          this.programs.forEach(function (program) {\n            return program.allocate(capacity);\n          });\n        }\n      }, {\n        key: \"process\",\n        value: function process() {\n          var args = arguments;\n          this.programs.forEach(function (program) {\n            return program.process.apply(program, _toConsumableArray(args));\n          });\n        }\n      }, {\n        key: \"computeIndices\",\n        value: function computeIndices() {\n          this.programs.forEach(function (program) {\n            if (typeof program.computeIndices === 'function') program.computeIndices();\n          });\n        }\n      }, {\n        key: \"bufferData\",\n        value: function bufferData() {\n          this.programs.forEach(function (program) {\n            return program.bufferData();\n          });\n        }\n      }, {\n        key: \"render\",\n        value: function render() {\n          var args = arguments;\n          this.programs.forEach(function (program) {\n            program.bind();\n            program.bufferData();\n            program.render.apply(program, _toConsumableArray(args));\n          });\n        }\n      }]);\n\n      return CompoundProgram;\n    }()\n  );\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateWebglRendererSettings = validateWebglRendererSettings;\nexports.WEBGL_RENDERER_DEFAULT_SETTINGS = void 0;\n\nvar _label = _interopRequireDefault(require(\"../canvas/components/label\"));\n\nvar _hover = _interopRequireDefault(require(\"../canvas/components/hover\"));\n\nvar _edgeLabel = _interopRequireDefault(require(\"../canvas/components/edge-label\"));\n\nvar _node = _interopRequireDefault(require(\"./programs/node.fast\"));\n\nvar _edge = _interopRequireDefault(require(\"./programs/edge\"));\n\nvar _edge2 = _interopRequireDefault(require(\"./programs/edge.arrow\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Sigma.js WebGL Renderer Settings\n * =================================\n *\n * The list of settings for the WebGL renderer and some handy functions.\n */\nfunction validateWebglRendererSettings(settings) {\n  // Label grid cell\n  if (settings.labelGrid && settings.labelGrid.cell && _typeof(settings.labelGrid.cell) === 'object' && (!settings.labelGrid.cell.width || !settings.labelGrid.cell.height)) {\n    throw new Error('sigma/renderers/webgl/settings: invalid `labelGrid.cell`. Expecting {width, height}.');\n  }\n}\n\nvar WEBGL_RENDERER_DEFAULT_SETTINGS = {\n  // Performance\n  hideEdgesOnMove: false,\n  hideLabelsOnMove: false,\n  renderLabels: true,\n  renderEdgeLabels: false,\n  // Component rendering\n  defaultNodeColor: '#999',\n  defaultNodeType: 'circle',\n  defaultEdgeColor: '#ccc',\n  defaultEdgeType: 'line',\n  labelFont: 'Arial',\n  labelSize: 14,\n  labelWeight: 'normal',\n  edgeLabelFont: 'Arial',\n  edgeLabelSize: 14,\n  edgeLabelWeight: 'normal',\n  // Labels\n  labelGrid: {\n    cell: null,\n    renderedSizeThreshold: -Infinity\n  },\n  // Reducers\n  nodeReducer: null,\n  edgeReducer: null,\n  // Features\n  zIndex: false,\n  // Renderers\n  labelRenderer: _label[\"default\"],\n  hoverRenderer: _hover[\"default\"],\n  edgeLabelRenderer: _edgeLabel[\"default\"],\n  // Program classes\n  nodeProgramClasses: {\n    circle: _node[\"default\"]\n  },\n  edgeProgramClasses: {\n    arrow: _edge2[\"default\"],\n    line: _edge[\"default\"]\n  }\n};\nexports.WEBGL_RENDERER_DEFAULT_SETTINGS = WEBGL_RENDERER_DEFAULT_SETTINGS;","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = \"precision mediump float;\\n\\nvarying vec4 v_color;\\n// varying vec3 v_barycentric;\\n\\nvoid main(void) {\\n  // if (any(lessThan(v_barycentric, vec3(0.01))))\\n  //   discard;\\n  // else\\n    gl_FragColor = v_color;\\n}\\n\"\n\n/***/ })\n/******/ ]);","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */,\n/* 1 */\n/***/ (function(module, exports) {\n\nmodule.exports = \"attribute vec2 a_position;\\nattribute vec2 a_normal;\\nattribute float a_thickness;\\nattribute float a_radius;\\nattribute vec4 a_color;\\nattribute vec3 a_barycentric;\\n\\nuniform vec2 u_resolution;\\nuniform float u_ratio;\\nuniform mat3 u_matrix;\\nuniform float u_scale;\\n\\nvarying vec4 v_color;\\n// varying vec3 v_barycentric;\\n\\nconst float arrow_ratio = 0.66;\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n\\n  float da = a_barycentric.x;\\n  float db = a_barycentric.y;\\n  float dc = a_barycentric.z;\\n\\n  float pow_ratio = 1.0 / pow(u_ratio, 0.5) * 2.0;\\n  float radius = (a_radius - 1.0) * pow_ratio;\\n  float thickness = a_thickness * pow_ratio / u_scale;\\n  float width = arrow_ratio * thickness / 2.0;\\n\\n  vec2 delta = vec2(\\n      da * ((radius) * a_normal.y)\\n    + db * ((radius + thickness) * a_normal.y + width * a_normal.x)\\n    + dc * ((radius + thickness) * a_normal.y - width * a_normal.x),\\n\\n      da * (-(radius) * a_normal.x)\\n    + db * (-(radius + thickness) * a_normal.x + width * a_normal.y)\\n    + dc * (-(radius + thickness) * a_normal.x - width * a_normal.y)\\n  );\\n\\n  delta /= u_resolution;\\n\\n  // Scale from [[-1 1] [-1 1]] to the container:\\n  vec2 position = (u_matrix * vec3(a_position, 1)).xy;\\n  position += delta;\\n\\n  // Applying\\n  gl_Position = vec4(position, 0, 1);\\n\\n  // v_barycentric = a_barycentric;\\n\\n  // Extract the color:\\n  v_color = a_color;\\n  v_color.a *= bias;\\n}\\n\"\n\n/***/ })\n/******/ ]);","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 2);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 2:\n/***/ (function(module, exports) {\n\nmodule.exports = \"attribute vec2 a_position;\\nattribute vec2 a_normal;\\nattribute float a_thickness;\\nattribute vec4 a_color;\\nattribute float a_radius;\\n\\nuniform vec2 u_resolution;\\nuniform float u_ratio;\\nuniform mat3 u_matrix;\\nuniform float u_scale;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\nvarying float v_thickness;\\n\\nconst float min_thickness = 1.8;\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n\\n  // Computing thickness in pixels\\n  float pow_ratio = 1.0 / pow(u_ratio, 0.5);\\n  float thickness = a_thickness * pow_ratio / u_scale;\\n\\n  // Min thickness for AA\\n  thickness = max(min_thickness, thickness);\\n\\n  // Arrow margin\\n  // NOTE: it seems we don't need a constant margin into the arrow\\n  float arrow_pow_ratio = pow_ratio * 2.0;\\n  float radius = abs(a_radius) * arrow_pow_ratio;\\n  float arrow_thickness = max(a_thickness * 2.5, 5.0) * arrow_pow_ratio / u_scale;\\n  float margin = radius + arrow_thickness - arrow_pow_ratio;\\n  float direction = sign(a_radius);\\n  vec2 pnormal = vec2(-direction * a_normal.y, direction * a_normal.x);\\n\\n  // Computing delta relative to viewport\\n  vec2 delta = (a_normal * thickness) / u_resolution;\\n  vec2 clamped = (pnormal * margin) / u_resolution;\\n\\n  vec2 position = (u_matrix * vec3(a_position, 1)).xy;\\n  position += delta + clamped;\\n\\n  // Applying\\n  gl_Position = vec4(position, 0, 1);\\n\\n  v_normal = a_normal;\\n  v_thickness = thickness;\\n\\n  // Extract the color:\\n  v_color = a_color;\\n  v_color.a *= bias;\\n}\\n\"\n\n/***/ })\n\n/******/ });","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 5:\n/***/ (function(module, exports) {\n\nmodule.exports = \"precision mediump float;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\nvarying float v_thickness;\\n\\nconst float feather = 2.6;\\nconst vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);\\n\\nvoid main(void) {\\n  float dist = length(v_normal) * v_thickness;\\n\\n  float t = smoothstep(\\n    v_thickness - feather,\\n    v_thickness,\\n    dist\\n  );\\n\\n  gl_FragColor = mix(v_color, color0, t);\\n}\\n\"\n\n/***/ })\n\n/******/ });","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 10);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 10:\n/***/ (function(module, exports) {\n\nmodule.exports = \"attribute vec2 a_position;\\nattribute vec2 a_normal;\\nattribute float a_thickness;\\nattribute vec4 a_color;\\n\\nuniform vec2 u_resolution;\\nuniform float u_ratio;\\nuniform mat3 u_matrix;\\nuniform float u_scale;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\nvarying float v_thickness;\\n\\nconst float min_thickness = 1.8;\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n\\n  // Computing thickness in pixels\\n  float pow_ratio = 1.0 / pow(u_ratio, 0.5);\\n  float thickness = a_thickness * pow_ratio / u_scale;\\n\\n  // Min thickness for AA\\n  thickness = max(min_thickness, thickness);\\n\\n  // Computing delta relative to viewport\\n  vec2 delta = (a_normal * thickness) / u_resolution;\\n\\n  vec2 position = (u_matrix * vec3(a_position, 1)).xy;\\n  position += delta;\\n\\n  // Applying\\n  gl_Position = vec4(position, 0, 1);\\n\\n  v_normal = a_normal;\\n  v_thickness = thickness;\\n\\n  // Extract the color:\\n  v_color = a_color;\\n  v_color.a *= bias;\\n}\\n\"\n\n/***/ })\n\n/******/ });","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 11);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 11:\n/***/ (function(module, exports) {\n\nmodule.exports = \"precision mediump float;\\n\\nvarying vec4 v_color;\\nvarying float v_border;\\n\\nconst float radius = 0.5;\\n\\nvoid main(void) {\\n  vec4 color0 = vec4(0.0, 0.0, 0.0, 0.0);\\n  vec2 m = gl_PointCoord - vec2(0.5, 0.5);\\n  float dist = radius - length(m);\\n\\n  float t = 0.0;\\n  if (dist > v_border)\\n    t = 1.0;\\n  else if (dist > 0.0)\\n    t = dist / v_border;\\n\\n  // gl_FragColor = mix(color0, v_color, t);\\n  gl_FragColor = mix(color0, v_color, t);\\n}\\n\"\n\n/***/ })\n\n/******/ });","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 12);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 12:\n/***/ (function(module, exports) {\n\nmodule.exports = \"attribute vec2 a_position;\\nattribute float a_size;\\nattribute vec4 a_color;\\n\\nuniform float u_ratio;\\nuniform float u_scale;\\nuniform mat3 u_matrix;\\n\\nvarying vec4 v_color;\\nvarying float v_border;\\n\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n\\n  gl_Position = vec4(\\n    (u_matrix * vec3(a_position, 1)).xy,\\n    0,\\n    1\\n  );\\n\\n  // Multiply the point size twice:\\n  //  - x SCALING_RATIO to correct the canvas scaling\\n  //  - x 2 to correct the formulae\\n  gl_PointSize = a_size * u_ratio * u_scale * 2.0;\\n\\n  v_border = (1.0 / u_ratio) * (0.5 / a_size);\\n\\n  // Extract the color:\\n  v_color = a_color;\\n  v_color.a *= bias;\\n}\\n\"\n\n/***/ })\n\n/******/ });","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loadProgram = loadProgram;\nexports.loadFragmentShader = exports.loadVertexShader = void 0;\n\n/**\n * Sigma.js Shader Utils\n * ======================\n *\n * Code used to load sigma's shaders.\n */\n\n/**\n * Function used to load a shader.\n */\nfunction loadShader(type, gl, source) {\n  var glType = type === 'VERTEX' ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER; // Creating the shader\n\n  var shader = gl.createShader(glType); // Loading source\n\n  gl.shaderSource(shader, source); // Compiling the shader\n\n  gl.compileShader(shader); // Retrieving compilation status\n\n  var successfullyCompiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS); // Throwing if something went awry\n\n  if (!successfullyCompiled) {\n    var infoLog = gl.getShaderInfoLog(shader);\n    gl.deleteShader(shader);\n    throw new Error(\"sigma/renderers/webgl/shaders/utils.loadShader: error while compiling the shader:\\n\".concat(infoLog, \"\\n\").concat(source));\n  }\n\n  return shader;\n}\n\nvar loadVertexShader = loadShader.bind(null, 'VERTEX'),\n    loadFragmentShader = loadShader.bind(null, 'FRAGMENT');\nexports.loadFragmentShader = loadFragmentShader;\nexports.loadVertexShader = loadVertexShader;\n\n/**\n * Function used to load a program.\n */\nfunction loadProgram(gl, shaders) {\n  var program = gl.createProgram();\n  var i, l; // Attaching the shaders\n\n  for (i = 0, l = shaders.length; i < l; i++) {\n    gl.attachShader(program, shaders[i]);\n  }\n\n  gl.linkProgram(program); // Checking status\n\n  var successfullyLinked = gl.getProgramParameter(program, gl.LINK_STATUS);\n\n  if (!successfullyLinked) {\n    gl.deleteProgram(program);\n    throw new Error('sigma/renderers/webgl/shaders/utils.loadProgram: error while linking the program.');\n  }\n\n  return program;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.floatColor = floatColor;\nexports.matrixFromCamera = matrixFromCamera;\nexports.extractPixel = extractPixel;\nexports.canUse32BitsIndices = canUse32BitsIndices;\n\nvar _matrices = require(\"./matrices\");\n\n/**\n * Sigma.js WebGL Renderer Utils\n * ==============================\n *\n * Miscelleanous helper functions used by sigma's WebGL renderer.\n */\n\n/**\n * Memoized function returning a float-encoded color from various string\n * formats describing colors.\n */\nvar FLOAT_COLOR_CACHE = {};\nvar INT8 = new Int8Array(4);\nvar INT32 = new Int32Array(INT8.buffer, 0, 1);\nvar FLOAT32 = new Float32Array(INT8.buffer, 0, 1);\nvar RGBA_TEST_REGEX = /^\\s*rgba?\\s*\\(/;\nvar RGBA_EXTRACT_REGEX = /^\\s*rgba?\\s*\\(\\s*([0-9]*)\\s*,\\s*([0-9]*)\\s*,\\s*([0-9]*)(?:\\s*,\\s*(.*)?)?\\)\\s*$/;\n\nfunction floatColor(val) {\n  // If the color is already computed, we yield it\n  if (typeof FLOAT_COLOR_CACHE[val] !== 'undefined') return FLOAT_COLOR_CACHE[val];\n  var r = 0,\n      g = 0,\n      b = 0,\n      a = 1; // Handling hexadecimal notation\n\n  if (val[0] === '#') {\n    if (val.length === 4) {\n      r = parseInt(val.charAt(1) + val.charAt(1), 16);\n      g = parseInt(val.charAt(2) + val.charAt(2), 16);\n      b = parseInt(val.charAt(3) + val.charAt(3), 16);\n    } else {\n      r = parseInt(val.charAt(1) + val.charAt(2), 16);\n      g = parseInt(val.charAt(3) + val.charAt(4), 16);\n      b = parseInt(val.charAt(5) + val.charAt(6), 16);\n    }\n  } // Handling rgb notation\n  else if (RGBA_TEST_REGEX.test(val)) {\n      var match = val.match(RGBA_EXTRACT_REGEX);\n      r = +match[1];\n      g = +match[2];\n      b = +match[3];\n      if (match[4]) a = +match[4];\n    }\n\n  a = a * 255 | 0;\n  var bits = (a << 24 | b << 16 | g << 8 | r) & 0xfeffffff;\n  INT32[0] = bits;\n  var color = FLOAT32[0];\n  FLOAT_COLOR_CACHE[val] = color;\n  return color;\n}\n/**\n * Function returning a matrix from the current state of the camera.\n */\n// TODO: it's possible to optimize this drastically!\n\n\nfunction matrixFromCamera(state, dimensions) {\n  var angle = state.angle,\n      ratio = state.ratio,\n      x = state.x,\n      y = state.y;\n  var width = dimensions.width,\n      height = dimensions.height;\n  var matrix = (0, _matrices.identity)();\n  var smallestDimension = Math.min(width, height);\n  var cameraCentering = (0, _matrices.translate)((0, _matrices.identity)(), -x, -y),\n      cameraScaling = (0, _matrices.scale)((0, _matrices.identity)(), 1 / ratio),\n      cameraRotation = (0, _matrices.rotate)((0, _matrices.identity)(), -angle),\n      viewportScaling = (0, _matrices.scale)((0, _matrices.identity)(), 2 * (smallestDimension / width), 2 * (smallestDimension / height)); // Logical order is reversed\n\n  (0, _matrices.multiply)(matrix, viewportScaling);\n  (0, _matrices.multiply)(matrix, cameraRotation);\n  (0, _matrices.multiply)(matrix, cameraScaling);\n  (0, _matrices.multiply)(matrix, cameraCentering);\n  return matrix;\n}\n/**\n * Function extracting the color at the given pixel.\n */\n\n\nfunction extractPixel(gl, x, y, array) {\n  var data = array || new Uint8Array(4);\n  gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, data);\n  return data;\n}\n/**\n * Function used to know whether given webgl context can use 32 bits indices.\n */\n\n\nfunction canUse32BitsIndices(gl) {\n  var webgl2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;\n  return webgl2 || !!gl.getExtension('OES_element_index_uint');\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isPlainObject = isPlainObject;\nexports.assign = assign;\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * Sigma.js Utils\n * ===============\n *\n * Various helper functions & classes used throughout the library.\n */\n\n/**\n * Checks whether the given value is a plain object.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nfunction isPlainObject(value) {\n  return _typeof(value) === 'object' && value !== null && value.constructor === Object;\n}\n/**\n * Very simple recursive Object.assign-like function.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\n\n\nfunction assign(target) {\n  target = target || {};\n\n  for (var i = 0, l = arguments.length <= 1 ? 0 : arguments.length - 1; i < l; i++) {\n    var o = i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1];\n    if (!o) continue;\n\n    for (var k in o) {\n      if (isPlainObject(o[k])) {\n        target[k] = assign(target[k], o[k]);\n      } else {\n        target[k] = o[k];\n      }\n    }\n  }\n\n  return target;\n}"],"sourceRoot":""}